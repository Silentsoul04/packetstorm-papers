<HTML>
<HEAD>
<TITLE>TRUSIX: Access Control Lists</TITLE>
</HEAD>
<BODY>
<H3 ALIGN=RIGHT>NCSC-TG-020-A<BR>VERSION-1</H3>
<H1 ALIGN=CENTER>NATIONAL COMPUTER SECURITY CENTER</H1>
<H1 ALIGN=CENTER>TRUSTED UNIX WORKING GROUP (TRUSIX)<BR>
RATIONALE FOR SELECTING<BR>
ACCESS CONTROL LIST FEATURES<BR>
FOR THE UNIX (R) SYSTEM</H1>
<H4 ALIGN=CENTER>18 August 1989</H4>
<HR>
<P ALIGN=CENTER><B>NATIONAL COMPUTER SECURITY CENTER</B><BR>
FORT GEORGE G. MEADE, MARYLAND 20755-6000</P>
<P ALIGN=RIGHT>NCSC-TG-020-A<BR>Library No. S-232,508</P>
<H1 ALIGN=CENTER><A NAME="HDR 2 7">FOREWORD</A></H1>
The National Computer Security Center (NCSC) formed the Trusted UNIX Working Group (TRUSIX) in 1987 to provide technical guidance to vendors and evaluators involved in the development of Trusted Computer System Evaluation Criteria (TCSEC) class B3 trusted UNIX* systems. The NCSC specifically targeted the UNIX operating system for this guidance because of its growing popularity among the government and vendor communities. By addressing the class B3 issues, the NCSC believes that this information will also help vendors understand how evaluation interpretations will be made at the levels of trust below this class.TRUSIX is making no attempt to address the entire spectrum of technical problems associated with the development of division B systems; rather, the intent is to provide examples of implementations of those security features discernible at the user interface that will be acceptable at this level of trust.<p>
TRUSIX is not intended to be a standards body. nor does it intend to produce a de facto standard to compete against POSIX. Additionally, the TRUSIX documents are not to be construed as supplementary requirements to the TCSEC. The TCSEC is the only metric against which the trustworthiness of an operating system will be evaluated.<p>
This document, "Rationale for Selecting Access Control List (ACL) Features for the UNIX System," is the first in a series of companion documents being produced by TRUSIX. The guidelines described in this document provide alternative methods for implementing ACLs in the UNIX system.<p>
Recommendations for revision to this guideline are encouraged and will be reviewed periodically by the NCSC. Address all proposals for revision through appropriate channels to:<p>

<DL>
<DD>National Computer Security Center
<DD>9800 Savage Road
<DD>Fort George G. Meade, MD 20755-6000
<DD> Attention: Chief, Technical Guidleines Division
</DL>
<P>
_________________________________ 18 August 1989 <BR>
Patrick R. Gallagher, Jr.<BR>
Director<BR>National Computer Security Center</P>
_______________<p>
* UNIX is a registered trademark of AT&amp;T<p>
<HR>
<H1 ALIGN=CENTER><A NAME="HDR 2 9">ACKNOWLEDGMENTS</A></H1>
Special recognition is extended to those members of the TRUSIX Working Group who participated in the Access Control List Subcommittee. Members of this subcommittee were: Craig Rubin, AT&amp;T Bell Laboratories (Co-Chair); Holly Traxler, National Computer Security Center (NCSC)/Institute for Defense Analyses (IDA) (Co-Chair); Bruce Calkins, NCSC; and Casey Schaufler, Sun Microsystems. Recognition is also extended to the following members of TRUSIX who provided input through discussion and comments: Bernie Badger, Harris Corporation; Caralyn Crescenzi, NCSC; Cynthia Irvine, Gemini Computers; Howard Israel, AT&amp;T Bell Laboratories; Frank Knowles. MITRE; James Menendez. NCSC; Dr. Eric Roskos, IDA; Rick Siebenaler, NCSC, Lucy Stasiak, AT&amp;T Bell Laboratories; Albert Tao, Gemini Computers; Dr. Charles Testa, Infosystems Technology, Incorporated (ITI), Mario Tinto, NCSC; Grant Wagner, NCSC; Larry Wehr, AT&amp;T Bell Laboratories; and Bruce D. Wilner, ITI.<p>
Acknowledgment is also extended to the members of the POSIX P1003.6 Security Subcommittee and to those members of the computer security community who contributed their time and expertise by actively participating in the review of this document.
<HR>
<H1 ALIGN=CENTER><A NAME="HDR 2 10">EXECUTIVE SUMMARY</A></H1>
The Trusted UNIX Working Group (TRUSIX) has examined the issues surrounding implementation of access control lists (ACLs) in the UNIX System and has identified a set of recommendations for implementors of ACL features. These recommendations balance issues of compatibility with existing applications, ease of use and acceptability to the end user9 and architectural simplicity with the requirements for systems evaluated according to the Trusted Computer System Evaluation Criteria (TCSEC). The recommendations reflect the collected opinions and analyses of the participating vendors, evaluators, and researchers regarding implementation of ACL features.<p>
The recommendations of TRUSIX with regard to ACLs are as follows:<p>
<UL>
<LI>ACLs are required for files IPC objects, and UNIX system domain sockets.
 Access control for sockets that use name spaces other than those local to
 the UNIX system (UDP, TCP) must be addressed in the specification and
 evaluation of the system involved, and are neither explicitly recommended
 nor exempted.
<P>
<LI>Access modes specifiable via ACLs should include read, write, and execute;
 other modes should be allowed to be added as desired, but no additional
 modes should be required to be supported.
<LI>Each ACL entry should specify permissions for either a user or a group,
 but not both.
<P>
<LI>Permissions granted by an ACL entry are masked by the group class file
 permission bits.
<P>
<LI>Multiple concurrent groups should be supported. In addition, some method
 of group subsetting should be provided. It is recommended that this
 subsetting allow the user to become a member of only one group at login
 time, then to dynamically add groups to or delete groups from the working
 group set as required.
<P>
<LI>A system-defined ordering of ACL evaluation that evaluates from most
 specific to least specific is recommended. Where multiple concurrent
 groups are in use, and more than one matching group is found in the ACL,
 permissions granted by all matching groups should be ORed together.
<P>
<LI>Modifications to mechanisms that change ownership, change the file
 permission bits, or access object attributes are not recommended.
<P>
<LI>Existing mechanisms for object access, inquiry, and deletion should not be
 changed, and new parameters should not be added. Instead, new mechanism
 should be created that make use of existing ones. The interface for
 mechanisms that create objects should not be changed, except for the
 possible creation of a default ACL.
<P>
<LI>For the new mechanisms that are added to support ACL operations, get/set
 operations should be used. These operations should be implemented via a
 single system call with command arguments to specify the various
 operations. For commands at the user interface, the names getacl and
 setacl are recommended.
<P>
<LI>Named ACLs need not be supported.
<P>
<LI>Provision of default ACLs for file system objects is recommended, along
 with a user-specifiable mechanism for indicating whether or not they
 should be used.
<P>
<LI>Provision of default ACLs for IPC objects is not recommended.
<P>
<LI>Default ACLs should be provided on a per-directory basis. Newly-created
 subdirectories should inherit the default ACL of the parent directory.
<P>
<LI>When a new object is created and ACL entries are attached via a default
 ACL, the file group-class permission bits are not affected unless an
 explicit mechanism is provided.
</UL>
The preceding list summarizes the recommendations of the Trusted UNIX Working Group. The main body of this document discusses the rationale for these recommendations and gives further details of the recommendations themselves. The appendix, the TRUSIX ACL Worked Example, gives an example of how these recommendations might be implemented.
<HR>
<H1 ALIGN=CENTER>CONTENTS</H1>
<UL>
<A HREF="#HDR 2 7"><B>FOREWORD</B></A>
<BR>
<A HREF="#HDR 2 9"><B>ACKNOWLEDGMENTS</B></A>
<BR>
<A HREF="#HDR 2 10"><B>EXECUTIVE SUMMARY</B></A>
<BR>
<A HREF="#HDR1 2 13"><B>1. Introduction</B></A>
<BR>
<A HREF="#HDR2 2 15"><B>2. Goals</B></A>
<BR>
<A HREF="#HDR3 2 17"><B>3. ACLs On Objects</B></A>

<UL>
<A HREF="#HDR3.1 3 17">3.1 ACLs On IPC Objects</A>
<BR>
<A HREF="#HDR3.2 3 18">3.2 ACLs On Sockets</A>
</UL>

<A HREF="#HDR4 2 18"><B>4. Additional Access Modes</B></A>

<UL>
<A HREF="#HDR4.1 3 19">4.1 Require Additional Access Modes</A>
<BR>
<A HREF="#HDR4.2 3 19">4.2 Prohibit Additional Access Modes</A>
<BR>
<A HREF="#HDR4.3 3 19">4.3 Allow Additional Access Modes (With Control)</A>
<BR>
<A HREF="#HDR4.4 3 19">4.4 Allow Additional Access Modes (Without Control)</A>
<BR>
<A HREF="#HDR4.5 3 20">4.5 Recommendation</A>
</UL>

<A HREF="#HDR5 2 20"><B>5. ACL Entry Type And Format</B></A>

<UL>
<A HREF="#HDR5.1 3 20">5.1 User And Group Entries</A>
<BR>
<A HREF="#HDR5.2 3 22">5.2 User Or Group Entries</A>
<BR>
<A HREF="#HDR5.3 3 23">5.3 Recommendation</A>
</UL>

<A HREF="#HDR6 2 24"><B>6. Relationship Of ACL And File Permission Bits</B></A>

<UL>
<A HREF="#HDR6.1 3 24">6.1 ACL Always Replaces File Permission Bits (Pure ACL)</A>
<BR>
<A HREF="#HDR6.2 3 25">6.2 Owner Selects ACL Or File Permission Bits</A>
<BR>
<A HREF="#HDR6.3 3 26">6.3 Independent ACL And File Permission Bits (AND)</A>
<BR>
<A HREF="#HDR6.4 3 27">6.4 Independent ACL And File Permission Bits (OR)</A>
<BR>
<A HREF="#HDR6.5 3 28">6.5 File Permission Bits Contained Within ACL</A>
<BR>
<A HREF="#HDR6.6 3 30">6.6 ACL Masked By File Permission Bits</A>
<BR>
<A HREF="#HDR6.7 3 31">6.7 Recommendation</A>
</UL>

<A HREF="#HDR7 2 32"><B>7. Group Semantics</B></A>

<UL>
<A HREF="#HDR7.1 3 32">7.1 Single Group Membership</A>
<BR>
<A HREF="#HDR7.2 3 33">7.2 Multiple Concurrent Group Membership</A>
<BR>
<A HREF="#HDR7.3 3 34">7.3 Multiple Concurrent Groups With Subsetting</A>
<BR>
<A HREF="#HDR7.4 3 35">7.4 Recommendation</A>
</UL>

<A HREF="#HDR8 2 35"><B>8. ACL Evaluation</B></A>

<UL>
<A HREF="#HDR8.1 3 35">8.1 Ordering Of Classes</A>
<BR>
<A HREF="#HDR8.2 3 36">8.2 User-Defined Ordering</A>
<BR>
<A HREF="#HDR8.3 3 36">8.3 System-Defined Ordering</A>
<BR>
<A HREF="#HDR8.4 3 37">8.4 Multiple Group Evaluation</A>
<BR>
<A HREF="#HDR8.5 3 38">8.5 Recommendation</A>
</UL>

<A HREF="#HDR9 2 38"><B>9. DAC Compatibility</B></A>

<UL>
<A HREF="#HDR9.1 3 39">9.1 Changing Ownership Of An Object</A>
<BR>
<A HREF="#HDR9.2 3 39">9.2 Changing The File Permission Bits</A>
<BR>
<A HREF="#HDR9.3 3 40">9.3 Creating Objects</A>
<BR>
<A HREF="#HDR9.4 3 40">9.4 Accessing Object Attributes</A>
<BR>
<A HREF="#HDR9.5 3 41">9.5 Accessing Object Data</A>
<BR>
<A HREF="#HDR9.6 3 41">9.6 Recommendation</A>
</UL>

<A HREF="#HDR10 2 42"><B>10. ACL System Calls And Commands</B></A>

<UL>
<A HREF="#HDR10.1 3 43">10.1 Recommendation</A>
</UL>

<A HREF="#HDR11 2 43"><B>11. Named ACLs</B></A>

<UL>
<A HREF="#HDR11.1 3 43">11.1 Recommendation</A>
</UL>

<A HREF="#HDR12 2 44"><B>12. Default ACLs</B></A>

<UL>
<A HREF="#HDR12.1 3 44">12.1 No Default ACLs</A>
<BR>
<A HREF="#HDR12.2 3 44">12.2 Require Default ACLs</A>
<BR>
<A HREF="#HDR12.3 3 45">12.3 Provide Default ACLs</A>
<BR>
<A HREF="#HDR12.4 3 45">12.4 Recommendation</A>
</UL>

<A HREF="#HDR13 2 45"><B>13. Location Of Default ACLs</B></A>

<UL>
<A HREF="#HDR13.1 3 45">13.1 System Wide</A>
<BR>
<A HREF="#HDR13.2 3 46">13.2 Per Process</A>
<BR>
<A HREF="#HDR13.3 3 46">13.3 Per GID Of Created File</A>
<BR>
<A HREF="#HDR13.4 3 46">13.4 Per Directory</A>
<BR>
<A HREF="#HDR13.5 3 46">13.5 Recommendation</A>
</UL>

<A HREF="#HDR14 2 47"><B>14. Interaction Of Default ACL Entries At File Creation</B></A>

<UL>
<A HREF="#HDR14.1 3 47">14.1 OR File Group Class Permission Bits</A>
<BR>
<A HREF="#HDR14.2 3 47">14.2 AND File Group Class Permission Bits</A>
<BR>
<A HREF="#HDR14.3 3 48">14.3 No Change To File Group Class Permission Bits</A>
<BR>
<A HREF="#HDR14.4 3 48">14.4 Recommendation</A>
</UL>

<A HREF="#HDR15 2 48"><B>15. Summary</B></A>
<BR>
<A HREF="#HDR 2 49"><B>APPENDIX: Worked Example</B></A>
<BR>
<A HREF="#HDR 2 102"><B>REFERENCES</B></A>
</UL>

<HR>
<H1>TRUSIX Task Force: Rationale For Selecting Access Control List<BR>
Features For The UNIX System</H1>

<H1><A NAME="HDR1 2 13">1. Introduction</A></H1>
The intent of this document is to explore the issues involved in extending the UNIX System discretionary access control (DAC) mechanism. DAC is a means of controlling access to an object based on the identity of subjects and/or groups to which they belong. The controls are discretionary in the sense that they are chosen by the object owner.<p>
The DAC mechanism employed in the current UNIX System was designed for efficiency, flexibility. and ease of use. This mechanism allows and encourages the sharing of information, but at a very coarse granularity, via the use of file permission bits. File permission bits are associated with three classes: owner (sometimes referred to as "user"), group. and other. Access for each class is represented by a three-bit field allowing for read, write, and execute-permissions.<p>
Several methods exist for allowing discretionary access control on objects. These methods include capabilities, profiles. access control lists (ACLs), protection bits, and password DAC mechanisms. The intent was to select a DAC mechanism with finer granularity than the current file permission bits, while maximizing the compatibility with both the current mechanism and POSIX P1003.1. Review of the methods described in A Guide to Understanding Discretionary Access Control in Trusted Systems(2), and of the desired outcome, point to the use of ACLs. It should be noted that ACLs can be considered a straightforward extension of the existing UNIX system protection bits, since the protection bits may be interpreted to be a limited form of an ACL, which always contains three entries.<p>
It has been suggested that the fine granularity of control provided by ACLs may be simulated in UNIX systems by using the group mechanism. Groups are lists of users which may be used to specify who may access a file. In the worst case9 all possible combinations of users would have to be represented in order to fully implement these lists. This corresponds to (2**M-1) groups, where M is the number of bits in the group-ID. Since the number of possible combinations of users needed to implement this scheme for N users is (2"N-1), the maximum number of users which could effectively utilize such a
system would be limited to the number of bits in the group-ID. This number (often 16 or 32) is an unreasonably small number for most UNIX systems and the management of the groups by users would be difficult. Also, this scheme does not allow for individual users in the lists to have different access rights. All users in the group would be forced to have the access rights given by the file group class permission bits. Some differences in access rights could be simulated by using the file other class permission bits, but not with the same functionality as provided by conventional ACLs.<p>
The DAC features explored in this rationale are based on the DAC features requested by customers, the class B3 DAC requirements described in the DoD Trusted Computer Systems Evaluation Criteria [1] (TCSEC), and the DAC mechanisms used in existing trusted systems (e.g., Multics). Based on these inputs9 it has been determined that the current DAC mechanism in the UNIX System is adequate for most needs and that the only enhancement required is to allow reasonable, finer-grained control of objects. This provides the capability to share or deny access to individually specified users and/or groups and meets the class B3 requirements of the TCSEC.<p>
The issues explored in this document will deal primarily with ACLs. Much of the terminology has been adopted from the P1003.1 document and the TCSEC; however, new terms will be defined when used. For most of the issues identified, alternative solutions are given along with a recommendation. Although an attempt was made to consider the' issues independently, it should be noted that sole of the issues are actually very dependent on each other and recommendations `made in some areas greatly influenced later recommendations.<p>
_______________<p>
* UNIX is a registered trademark of AT&amp;T<p>
<HR>
<H1><A NAME="HDR2 2 15">2. Goals</A></H1>
The primary goal in extending discretionary access control in the UNIX system is to provide a finer granularity of control in specifying user and/or group access to objects. This can be achieved through the addition of access control lists. The following is a list of additional goals for the extended DAC mechanism:<p>
<UL>
<LI>The mechanism should provide compatibility with the existing (currently
 P1003.1) and emerging POSIX standards and with the current UNIX System
 DAC mechanism. In the unlikely event of a conflict between the current
 UNIX System DAC mechanism and POSIX, the POSIX interpretation will be
 used. In addition, the semantics of existing interfaces should be
 maintained.
<P>
<LI>The following requirements for DAC in the TCSEC at class B3 should be
 fulfilled. "The TCB shall define and control access between named users
 and named objects (e.g., files and programs) in the ADP system. The
 enforcement mechanism (e.g., access control lists) shall allow users to
 specify and control sharing of those objects, and shall provide controls
 to limit propagation of access rights. The discretionary access control
 mechanism shall either by explicit user action or by default, provide that
 objects are protected from unauthorized access. These access controls
 shall be capable of specifying, for each named object, a list
 of named individuals and a list of groups of named individuals with their
 respective modes of access to that object. Furthermore. for each such
 named object, it shall be possible to specify a list of named
 individuals and a list of groups of named individuals for which no
 access to the object is to be given. Access permissions to an object by
 users not already possessing access permission shall only be assigned by
 authorized users."
<P>
<LI>Reasonable vendor extensions to the DAC mechanism should not be precluded.
 For example, the specification of read, write and execute permissions
 should be supported. Other permissions should not be required nor
 should they be precluded as extensions. A minimum set of new interfaces
 and error codes should be provided. The new command interfaces provided
 for the user must be easy to use and the existing interfaces should
 continue to work as expected.
<P>
<LI>Intermixing use of the existing and newly-defined DAC functions/commands
 should provide reasonable results. Security should be maximized by
 opting for more restrictive rather than less restrictive decisions when
 a choice must be made.
<P>
<LI>When changing DAC on an object, at no time shall access be more permissive
 than either the initial or resulting access.
</UL>
<HR>
<H1><A NAME="HDR3 2 17">3. ACLs On Objects</A></H1>
A system can support several different types of objects, e.g., system objects, public objects, named objects. System objects are entities internal to the TCB (e.g., system data structures) not directly accessible by the normal user and, as such, do not require discretionary access control. Public objects are objects readable but unmodifiable to the normal user (e.g., system clock) and thus also do not require discretionary access control. Named objects are objects readable and modifiable at the user interface (e.g., text files). The TCSEC class B3 requirement for DAC states that access control must be enforced on all named objects in the system [1]. Although there may be some variance among different UNIX system implementations, there are two common classes of named objects that require ACLs. These classes are files (including regular. directory. special. and named pipes), and named IPC objects (including shared memory, message queues, semaphores, and sockets).<p>
It is these classes of objects that will be protected by the discretionary access control alternatives described later in the paper. It should be pointed out, however, that discretionary access can not always be completely determined solely by the file permission bits and the ACL associated with the object. It is possible to have objects which have been administratively configured for a specific access and thus not completely affected by user DAC, e.g., a file system mounted read-only. There are other instances where discretionary access of objects may be time-dependent and thus not completely based on a current DAC setting. Examples of this would be the inability to write a shared-text file while it is being executed or trying to execute a file while it is open for writing. These situations are acknowledged special cases and will not be considered in the general discussion of determining effective discretionary access.<p>
<H2><A NAME="HDR3.1 3 17">3.1 ACLs On IPC Objects</A></H2>
IPC objects are named objects and are thus require ACLs at class B3. Note that this does not include unnamed pipes which can only be used to connect related processes. Although the semantics of IPC mechanisms are slightly different from those of file system objects, a DAC scheme similar to that used for file system objects should easily be adaptable to IPC objects. For example, message queues utilize both a creator and an owner of an IPC object and maintain creator and owner UIDs and GIDs (cuid,uid, cgid,gid). User access is checked against the cuid and the uid, and group access is checked against the cgid and gid. This situation can easily be represented with ACLs by using additional ACL entries to represent the creator UID and GID. Additionally, some access modes associated with file system objects, such as execute, may not be applicable to IPC objects. This does not cause a problem as long as the modes are a subset of those defined for file system objects.<p>
<H2><A NAME="HDR3.2 3 18">3.2 ACLs On Sockets</A></H2>
Sockets are named objects and would thus require ACLs at class 83. UNIX system domain sockets use the file system name space for access control decisions and currently have file permission bits associated with them. Thus, domain sockets would also need to have ACLs associated with them. Other types of sockets which use other name spaces (UDP. TCP) are currently not protected with any type of access control. Since it is not clear whether these types of sockets could currently be included in an evaluated configuration, they will not be addressed at this time.<p>
<HR>
<H1><A NAME="HDR4 2 18">4. Additional Access Modes</A></H1>
Existing UNIX systems support three access modes: read, write, and execute/search. Additional access modes are conceivable, and may be convenient to add while adding ACLs. Various possibilities include:<p>
<UL>
<LI>read attributes of object
<LI>write attributes of object
<LI>append only to object
<LI>truncate data of object
<LI>delete object
<LI>lock object
<LI>restrict setuid execution of object
<LI>restrict access of object based on time.
</UL>
Note that this is not an all-inclusive list.<p>
In this and subsequent sections, alternative implementations of a given topic are examined, followed by the TRUSIX recommendation.<p>
<H2><A NAME="HDR4.1 3 19">4.1 Require Additional Access Modes</A></H2>
In this approach to handling additional access modes, new access modes would be defined and required. This limits the availability of compliant implementations and impacts compatibility.<p>
<H2><A NAME="HDR4.2 3 19">4.2 Prohibit Additional Access Modes</A></H2>
In this approach, new access modes would explicitly not be allowed. Due to loss of flexibility, compliance with this scheme would limit implementation.<p>
<H2><A NAME="HDR4.3 3 19">4.3 Allow Additional Access Modes (With Control)</A></H2>
<B></B>In this approach, new access modes would not be defined. Instead. the concept of and mechanism for adding new access modes would be defined. This allows a vendor to produce whatever additional access modes are desired. Since the mechanism for doing so is defined there is little chance of collisions or contradictions. The mechanisms must be defined and agreed upon by some regulating body which allocates access bits. Note no such body currently exists which has been tasked to allocate access bits.<p>
<H2><A NAME="HDR4.4 3 19">4.4 Allow Additional Access Modes (Without Control)</A></H2>
In this approach, additional access modes are neither defined nor precluded. This method allows a vendor to produce whatever additional access modes are desired, but there is no mechanism provided for adding new modes. There would be no control on the access modes vendors might add.<p>
<H2><A NAME="HDR4.5 3 20">4.5 Recommendation</A></H2>
We recommend allowing additional access modes, without control. There should be nothing precluding the addition of new access modes if desired. However, since there is nothing currently in the POSIX P1003.1 standard concerning additional access modes, no new access modes or mechanisms need be defined.<p>
<HR>
<H1><A NAME="HDR5 2 20">5. ACL Entry Type And Format</A></H1>
The manner in which an ACL entry refers to a user or group of users is an important factor in the usability of an ACL mechanism. The alternatives are to have an ACL entry contain either a user or group in an entry. or to have an ACL entry contain both a user and group. The issue is which of the alternatives is more suitable to a system utilizing ACLs.<p>
<H2><A NAME="HDR5.1 3 20">5.1 User And Group Entries</A></H2>
A user and group entry contains a reference to both a specific user and a specific group together as a [UID,GID] pair. The UID-specific and GID-specific entries can be represented as special "wildcard" cases (denoted by *) meaning any user or group will match that entry. Using this method, an ACL entry may refer to one user in a particular group [UID,GID], one user in any group [UID,*], any user in a particular group [*,GID], or any user in any group [*,*] which is equivalent to the file other class permission bits. A typical ACL utilizing entries of this type might look like the following:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=RIGHT>user1.projA<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=RIGHT>user2.projB<TD ALIGN=CENTER>r--
<TR><TD ALIGN=RIGHT>user3.*<TD ALIGN=CENTER>rwx
<TR><TD ALIGN=RIGHT>*.projA<TD ALIGN=CENTER>r--
<TR><TD ALIGN=RIGHT>*.*<TD ALIGN=CENTER>---
</TABLE>
Implementations of protected subsystems is the only clear example that suggests using user and group ACL entries as a pair. Using the UNIX system setgid-on-exec feature, it is possible to build protected subsystems. Consider the following example which makes use of this feature.<p>
A database of tapes is maintained in /etc/tapedata. The database administrator (DBA) of the database wishes to produce a utility to control access to this database.To begin with, there are some rules for dealing with the database. Some users should have read and write access, others just read access, and still others should have no access to the database. Readers should only see data about their own tapes. In addition, since other database utilities have poor error handling, all updates to the database need to be made in the correct format.<p>
The DBA has written a utility named tapedb which can read and update the database. /etc/tapedata and tapedb both have the group tape associated with them, and tapedb has the set-group-id bit on. The DBA has also created an ACL for /etc/tapedata which contains the following entries:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=RIGHT>user1.tape<TD ALIGN=CENTER>r--
<TR><TD ALIGN=RIGHT>user2.tape<TD ALIGN=CENTER>r--
<TR><TD ALIGN=RIGHT>user3.tape<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=RIGHT>user4.tape<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=RIGHT>*.*<TD ALIGN=CENTER>---
</TABLE>
All users named in the ACL (in group tape) may read the database Only user3 and user4 (in group tape) may update the database. If the only way for a user to be a member of group tape is by executing tapedb, then the DBA is satisfied that /etc/tapedata is adequately protected.<p>
While this example suggests a useful application of user and group ACL entries, there are other ways to implement the example which do not require this ACL entry type functionality. As described in the following section, the same effect can be achieved through ACLs containing user or group entries.<p>
Additionally, identification by a user and group pair is not used in a UNIX System. In some systems, a user is identified by a user-ID, group-ID pair. In Multics, for example, a user is identified by a user-ID, project-ID pair. where a project-ID is equivalent to a group-ID on the UNIX system. User1 in projA. on a Multics system, is distinct from userl in projB. Since Multics users do not have the capability to change groups9 the only way for a user to be identified with another project would be to log in with another group-ID. In UNIX systems, however. a user is really only identified by the user-ID. Also, a user can easily change group-ID through the newgrp command or be associated with several groups at the same time if using a system with multiple groups. Thus, controlling access for a user while in a specific group is not as useful in a UNIX system.<p>
<H2><A NAME="HDR5.2 3 22">5.2 User Or Group Entries</A></H2>
A user or group entry contains a reference to either a specific user or a specific group, but only one at a time. Consider the following example, where u indicates the user class, g indicates the group class, and o indicates the other class:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>u: user1<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=LEFT>u: user2<TD ALIGN=CENTER>r--
<TR><TD ALIGN=LEFT>u: user3<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=LEFT>u: user4<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=LEFT>g: projA<TD ALIGN=CENTER>r--
<TR><TD ALIGN=LEFT>g: projB<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=LEFT>o:<TD ALIGN=CENTER>rw-
</TABLE>
<P>
To address the protected subsystem implementation, consider again the tape database example described in the previous section. Rather than controlling access to the data, access can be controlled on two subprograms; one which reads data, the other which updates data. The ACL on the database, /etc/tapedata would be:<P>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>g: tapereaders<TD ALIGN=CENTER>r--
<TR><TD ALIGN=LEFT>g: tapewirters<TD ALIGN=CENTER>rw-
<TR><TD ALIGN=LEFT>o:<TD ALIGN=CENTER>---
</TABLE>
<P>
The user interface for access to the database is tapedb. The program tapedb is not setgid, however, it invokes two other programs, tapedb_read and tapedb_write, that are setgid. Only users allowed to read the database have execute permission on, tapedb_read, while only those allowed to update the database may execute tapedb_write. The ACL on tapedb_read would be:<P>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>u: user1<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>u: user2<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>u: user3<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>u: user4<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>o:<TD ALIGN=CENTER>---
</TABLE>
<P>
The ACL on tapedb_write would be:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>u: user3<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>u: user4<TD ALIGN=CENTER>--x
<TR><TD ALIGN=LEFT>o:<TD ALIGN=CENTER>---
</TABLE>
The program tapedb_read runs setgid to the group <B>tapereaders</B>, and the program tapedb_write runs setgid to the group <B>tapewriters</B>.<p>
Thus, the same protected subsystem can be provided through ACLs of type user or group.<p>
The main advantage of this scheme is that it provides more clarity for the user. This is considered to be a very important advantage as a user's understanding of such a mechanism is essential in promoting its correct usage. Additionally, this scheme removes the need for wildcard specifiers, thus eliminating the potential problems of picking an unused character as a specifier.<p>
<H2><A NAME="HDR5.3 3 23">5.3 Recommendation</A></H2>
User or group entries in ACLs are recommended. Since there is no clear need for the user-group paired entry scheme and there are several advantages to the user or group scheme, the user or group scheme is the preferred alternative. Examples were examined which claimed to require the use of user-group paired entries. One such example deals with protected subsystems as described above. Protected subsystems, a useful and important feature in a trusted system, can be implemented through other means not requiring user-group paired entries. We have "found that this is a limited class of applications and may be implemented with the user or group scheme with minimal effort. For UNIX systems with multiple groups, the user and group scheme becomes more difficult when determining access. Additionally, the user or group scheme follows the idea in UNIX systems that a user is only identified by user-ID and gives no special meaning to what a user can do while only in a certain group. Finally, although simplicity is a very subjective measure, in comparing the two alternatives the advantage of simplicity outweighs the ability to specify both a user and a group in a single entry.<p>
<HR>
<H1><A NAME="HDR6 2 24">6. Relationship Of ACL And File Permission Bits</A></H1>
ACLs expand upon the discretionary access control facility which is already provided by the file permission bits. Although file permission bits do not meet the TCSEC class B3 requirement for DAC, they are sufficient for many uses and are the only mechanism available to existing applications. Existing applications that are security-conscious use file permission bits to control access. The relationship between the ACL and the file permission bits is important to existing programs in order to maintain compatibility. For example, use of <B>chmod</B>("object" 0) should continue to work, denying subsequent opens to an object. The following sections discuss possible approaches to handling the interaction of ACLs with file permission bits. Any references to default ACLs will be fully described in the Default ACLs section.<p>
<H2><A NAME="HDR6.1 3 24">6.1 ACL Always Replaces File Permission Bits (Pure ACL)</A></H2>
In this approach, the file permission bits are no longer consulted for DAC decisions. Instead, each object always has an ACL and the ACL completely determines access.<p>
Consider the following example illustrating this scheme. Assume User1 and User2 are members of the group "GroupA" and User3 and User4 are not.<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
</TABLE>
<P>
In this example the file permission bits would have no effect on the access control decision. User3 is able to read, write and execute the file. User2 is able to read it, but not to execute or write to the file. The file permission bits are completely ignored.<p>
The resulting pure ACL system does not have to worry about interactions between the ACL and the file permission bits, since the latter are not used for access control decisions. A single, well defined access policy is employed. Applications which should make use of DAC are forced to understand the new rules.<p>
The major disadvantage of this scheme, however, is that compatibility is lost. Every DAC cognizant program, and that should be every program that manipulates the discretionary access control information on an object needs to be changed to understand ACLs.<p>
<H2><A NAME="HDR6.2 3 25">6.2 Owner Selects ACL Or File Permission Bits</A></H2>
In this approach, either the file permission bits or the ACL are consulted for the access control decision on a per object basis. The owner determines whether the file permission bits or the ACL is used. The system call chmod returns an indicative error if the object has an ACL, but otherwise sets the file permission bits.<p>
Consider the two following examples which illustrate this approach. Once again assume User1 and User2 are members of the group "GroupA" and User3 and User4 are not.<p>
Example A (ACL selected):<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
</TABLE>
<P>
Since there is an ACL on this file the access control is the same as in the previous example.<p>
Example B (file permission bits selected):<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:<TD ALIGN=LEFT>NONE
</TABLE>
<P>
Since there are no ACL entries on this file the access control ~r determined by the permission bits. User2 (owner) has all access permissions to the file. User1 (a user in GroupA) is allowed read and execute access. User3 and User4 ("other" users) can only execute the file.<p>
The resulting system behaves like a file permission bit based system if no one ever sets ACLs and like the pure ACL system if a default ACL mechanism is in use. Thus, either environment can be supported.<p>
The compatibility issues raised in the previous section apply here as well. In addition, the programs have to determine which access control mechanism applies to each object created and set the DAC accordingly.<p>
<H2><A NAME="HDR6.3 3 26">6.3 Independent ACL And File Permission Bits (AND)</A></H2>
In this approach, both the file permission bits and the ACL are consulted for the discretionary access control decision on a per object basis. Access is granted if and only if it is granted by both the ACL and the file permission bits.<p>
Consider the following example, which illustrates this approach. For this example, assume only User2 is in GroupA.<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
</TABLE>
<P>
In the example above, the file permission bits imply that User1 has execute permission, whereas the permissions specified in the ACL imply that User1 has full access. Without knowing which group User 1 is in, one cannot predict whether or not User1 can read the file. If User1 is in group GroupA, then User1 will have read and execute permissions. If User1 is not in group GroupA, then only execute permission will be granted. Similarly, without knowing User3's group, one cannot predict whether or not User3 has read access. User4 will have no possibility of access, due to no permissions specified in the ACL entry. As the example illustrates, there is no way to get a full ACL view with this scheme.<p>
With this scheme, some compatibility is maintained. Calls to chmod have the desired effect from the restrictive point of view. ACL entries can further restrict access.<p>
Making use of the ACL as the effective access control mechanism requires that the file permission bits be set wide-open (i.e., read, write, and execute bits are set for user, group and other). In situations where ACLs are not properly set, a new object will become generally accessible. Likewise, if the ACL is removed then the object will again be generally accessible. This scheme also allows for misleading status information given to programs which only use the existing mechanism.<p>
<H2><A NAME="HDR6.4 3 27">6.4 Independent ACL And File Permission Bits (OR)</A></H2>
In this approach, both the file permission bits and the ACL are consulted for the discretionary access control decision on a per object basis. Access is granted if it is granted by either the ACL or the file permission bits. The ACL is used to grant access beyond what is set in the file permission bits.<p>
Consider the following example illustrating this approach. Assume only User2 is in GroupA.<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
</TABLE>
<P>
User1, User2, and User3 have read, write, and execute access. User4 has execute access.<p>
Again, some compatibility is maintained. Calls to chmod have the desired effect from the permissive point of view. The previous alternative's problem of leaving the permission bits wide-open is thus avoided.<p>
The problem with this scheme, however, is that a <B>chmod</B> call which would deny all access (<B>chmod</B>("object", 0)) in a system without ACLs will not do so here.<p>
<H2><A NAME="HDR6.5 3 28">6.5 File Permission Bits Contained Within ACL</A></H2>
In this approach, only the ACL is consulted for discretionary access control decisions. The file permission bits are replaced by three "base" entries in the ACL. Calls to <B>chmod</B> modify the <B>owner, group, and other</B> entries contained in the ACL. Calls to <B>stat</B> read this information from the ACL.<p>
In the following two examples assume the <B>owner</B> entry is evaluated before additional user entries, and the <B>group</B> entry is evaluated before additional gr1oup entries.<p>
Example A:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center><B>owner</B><TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
<TR><TD ALIGN=Center><B>group</B><TD ALIGN=LEFT>---
<TR><TD ALIGN=Center><B>other</B><TD ALIGN=LEFT>---
</TABLE>
<P>
In this example. it is not clear what permissions User2 is to be granted, since a particular method for determining owner access has not been specified for the case where an additional user entry also names the owner. User2 could be granted read, write, and execute access as the owner. read access only, as per the explicit entry for User2, or some combination of the two (e.g., the AND or OR of the two). User1, User3, and User4 get their access from their ACL entries.<p>
Example B: (After a <B>chmod</B>("object", 0))<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>---------
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center><B>owner</B><TD ALIGN=LEFT>---
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
<TR><TD ALIGN=Center><B>group</B><TD ALIGN=LEFT>---
<TR><TD ALIGN=Center><B>other</B><TD ALIGN=LEFT>---
</TABLE>
<P>
Changing the file permission bits to zero does not change the permissions granted to User1, User3, and User4, since their access is based on ACL entries. User2's access may change depending on how owner access is determined when additional user entries naming the owner also exist.<p>
If no additional entries are added to the ACLs, this system looks like a system without ACLs. The literal meaning of the file permission bits is preserved in the ACL.<p>
As in the previous alternative, however, a <B>chmod</B> call which would deny all access (<B>chmod</B>("object", 0)) in a system without ACLs will not do so here.<p>
<H2><A NAME="HDR6.6 3 30">6.6 ACL Masked By File Permission Bits</A></H2>
In this approach, both the file permission bits and the ACL are used for determining the discretionary access control decision. The access indicated in the ACL entry is logically ANDed (masked) with one or more of the file permission bit classes (file owner, file group, or file other class) to determine the effective DAC permission.<p>
Example:<p>
<TABLE ALIGN=CENTER>
<TR><TD ALIGN=LEFT>File Owner/Group:<TD ALIGN=LEFT>User2/GroupA
<TR><TD ALIGN=LEFT>File Permission Bits:<TD ALIGN=LEFT>rwxr-x--x
<TR><TD ALIGN=LEFT>ACL Entries:
<TR><TD ALIGN=Center>User1<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User2<TD ALIGN=LEFT>r--
<TR><TD ALIGN=Center>User3<TD ALIGN=LEFT>rwx
<TR><TD ALIGN=Center>User4<TD ALIGN=LEFT>---
</TABLE>
<P>
Assume that the group file permission bits are chosen as the mask, i.e., all ACL entries will be ANDed against the file group class permission bits. User2, being the owner, gets read, write, and execute access to the file. User3 is allowed read and execute access. User1 is allowed read and execute access, the write access is disallowed by the file permission bits. User4 is not allowed any access to the file.<p>
Calls to <B>chmod</B> have the desired effect from the restrictive point of view but not necessarily from the permissive point of view. Since the bits of the masked field will most likely be set wide-open, the literal meaning of the field chosen for the mask appears to be lost. The POSIX standard, however, allows for the extended meaning of the group class permission. bits.<p>

<H2><A NAME="HDR6.7 3 31">6.7 Recommendation</A></H2>
We recommend the <EM>ACL Masked By File Permission Bits</EM> approach. This is the most reasonable approach when trying to balance security and compatibility. The question of designating the masking field must still be resolved. The file group class permission bits are the preferred masking field, even though they encourage permissive default access by the owning group. This choice must be made because the use of the file owner class would cause compatibility problems in programs which attempt to establish "owner-only" access, whereas the designation of the file other class could leave objects open to attack were an ACL removed or never present. An additional option of masking user entries with the file owner class permission bits and group entries with the file group class permission bits has the same disadvantages as masking against only the file owner class. When masking against the file group class, the permissions indicate the least upper bound of the permissions allowed for the ACL entries and the user and other fields retain their previous semantics.<p>
To summarize the approaches identified in this section:<p>
The ACL Masked By File Permission Bits approach is a compromise for both security and compatibility.<p>
The Independent ACL And File Permission Bits (AND) approach suffers from the serious flaw that the file permission bits must be set very permissively in order to allow the ACL entries to predominate in the discretionary access calculation. A simple mistake in setting the ACL could grant object access to significantly more users than was intended.<p>
The Independent ACL And File Permission Bits (OR) approach may require that both ACL and the file permission bits be changed in order to deny a particular access. Thus, existing programs could believe that they had prevented access when they, in fact, had not. Similarly, in the File Permission Bits Contained Within ACL approach, removing "other" permission might not have the desired effect9 since, the owner, group, and other entries may not be the only ones in the ACL. In neither case does a call to <B>chmod</B> with a zero argument unequivocally revoke access from all users as might be expected.<p>
Whichever DAC scheme is ultimately selected, an appropriate balance must be struck between the mutually conflicting concerns of compatibility and security. In a DAC scheme where <B>chmod</B> cooperates with ACLs, <B>chmod</B> must not grant inappropriate access or require unreasonable (i.e., permissive public access) defaults.<p>
Barring compatibility, the alternatives of ACLs replacing file permission bits (Pure ACLs and On Demand) would be the most elegant way of enhancing DAC for UNIX systems. By abandoning file permission bits, however, these schemes have been rendered incompatible with existing systems. Thus, they are not considered for a POSIX-compliant UNIX system DAC scheme.<p>
<HR>
<H1><A NAME="HDR7 2 32">7. Group Semantics</A></H1>
There are various ways of using the UNIX system group mechanism when grouping system users. In designing ACLs it is important to understand the possible semantics and provide enough flexibility to properly support these semantics. Initially, there are no restrictions on how users can be grouped. Various possibilities include:<p>
<UL>
<LI>a shorthand way of referring to groups of subjects<p>
<LI>a method of grouping project work by group access rights<p>
<LI>privileged roles<p>
<LI>accountability (file ownership)<p>
</UL>
The issue arises. however, of how to deal with user membership when considering these possible grouping mechanisms. For example, should a user be permitted to be a member of more than one group at any given time? If so. should there be a mechanism provided to allow the user to control group membership? These issues will be addressed in the following sections.<p>
<H2><A NAME="HDR7.1 3 32">7.1 Single Group Membership</A></H2>
Under a single membership scheme, a user can only be a member of one specific group at any given time. All discretionary access checks will be made with respect to the user's OlD and a single GID. A user will only be able to change his/her group through the use of the newgrp command. This scheme is easy to implement and introduces no additional complexity with respect to evaluating access within an ACL. Additionally. it would certainly be acceptable in a class B3 system.<p>
<H2><A NAME="HDR7.2 3 33">7.2 Multiple Concurrent Group Membership</A></H2>
Under a multiple concurrent group scheme, a user can be a member of more than one group at the same time. This scheme introduces some complexity when evaluating user access by allowing more than one ACL entry of equal specificity to apply to a user simultaneously. For example, if a user is a member of several groups at the same time and tries to access an object with an ACL containing entries which match the user on more than one group, what will the resulting access be? There ar several ways of determining the resulting access in such a case. These are discussed under ACL Evaluation.<p>
Another concern with the use of multiple concurrent groups is the possibility of violating the least privilege principle. With multiple concurrent groups if a user is in several groups at once, he/she is granted access to all of those groups at all times rather than to just the ones he/she needs at any given time. This could be contrary to the idea of a user having a minimal set of privileges necessary to perform a particular function at any given time.<p>
It can be argued, however, that the least privilege requirement in the TCSEC only applies to TCB architecture, making this issue irrelevant for DAC. On the other hand there may be a problem with a system which implements privileged roles through the group mechanism. The TCSEC class B3 Trusted Facility Management requirement states that separate roles must be assigned to operator and administrator functions and that each role be restricted to performing only those functions necessary for that role. Given a system, therefore, which uses the group mechanism to assign roles and grant access based on role identity to parts of the system which would otherwise be inaccessible, it is clear that least privilege could be violated through the use of multiple concurrent groups. The violation would occur if the user who was a member of the group assigned to a privileged role could also be a member of one or more additional groups. Proper administration of these privileged groups, however. could still allow for the use of multiple groups. but a subsetting capability, as described in the next subsection, would then be required.<p>
Improperly controlled multiple concurrent groups with groups representing privileged roles could therefore be a violation of the least privilege principle. This would result in a failure to meet the class B3 requirements. This is only one specific implementation, however, and it is certainly conceivable that multiple concurrent groups could be implemented in such a way as to not be a violation of least privilege. The multiple concurrent group scheme is currently a feature in some UNIX systems and is thought to be an extremely useful and necessary feature to those who use it. Multiple concurrent groups would also be compatible with the POSIX standard<p>
<H2><A NAME="HDR7.3 3 34">7.3 Multiple Concurrent Groups With Subsetting</A></H2>
Another problem associated with multiple concurrent groups arises from the fact that currently when a user logs on to a system he/she automatically becomes a member of all of the groups that he/she is allowed membership in. There is no way for the user to only be active in a subset of his/her possible group set. Although there is no explicit requirement in the TCSEC precluding this, the TCSEC does seem to imply that a user should by default have a minimal amount of access rights at login.<p>
There are several ways of approaching this problem; any of these methods would be a possible and acceptable means of resolving this problem. First, it is necessary to consider whether a user should be able to add or delete groups from his/her group set and if so, with what restrictions. A user should certainly not be allowed to add groups for which he/she is not authorized. Therefore each user should have an "allowable group set" which consists of all groups that user has been given authorization to be a member of. Adding groups other than those which appear in this allowable group set would be unacceptable.<p>
There are at least two ways to allow a user to work with a subset of his/her allowable group set. The first would be to keep the current scheme where a user becomes a member of all of his/her groups at login, but provide the user with a means (through some system call or command) to drop specific groups if desired and work as a member of some subset of his/her allowable group set. A command would allow a user the capability but require an explicit action to do so. A system call, on the other hand, would provide the means for restriction through a program which could be set up to run automatically for the user. This would mean, however, that the set of groups would either be hardcoded into the program or be set through some type of configuration file. Another possible approach would be to provide a mechanism that would cause a program's groups to be restricted when that program is executed. Although this eliminates the user having to remember to restrict his/her groups or having to hardcode a group set into a program, it would add further complexity to the system.<p>
<H2><A NAME="HDR7.4 3 35">7.4 Recommendation</A></H2>
We recommend that the multiple concurrent group capability be provided along with some method of subsetting. The preferred method would be to only allow the user to become a member of one group at login and provide him/her with a means of dynamically adding/deleting to his/her working group set. This recommendation, of course, may conflict with implementations which use the group mechanism for privilege roles.<p>
<HR>
<H1><A NAME="HDR8 2 35">8. ACL Evaluation</A></H1>
This issue deals with how an ACL is evaluated to determine access rights of a subject to a particular object. There are several possible ordering methods for ACL evaluation, as well as several different ways to evaluate multiple group entries.<p>
Two levels of ordering must actually be considered when deriving an ACL evaluation scheme; the ordering of the classes (user, group, other), and then the ordering of the entries within each class.<p>
<H2><A NAME="HDR8.1 3 35">8.1 Ordering Of Classes</A></H2>
It would certainly be possible to specify an ordering of any combination of the three classes, user, group, and other. However, since both the POSIX standard and all current UNIX systems specify a "user, then group, then other" ordering, (or most-to-least specific), when evaluating access with permission bits, this ordering should be maintained for ACLs as well.<p>
The method of evaluating an ACL in a most-to-least specific manner can be described as follows. The owner identity of the object is first checked against the effective identity of the subject. If there is a match the search stops. Next, a check is made against the owning group identity of the object and the effective group of the subject. If there is a match and the subject does not have multiple groups, the search stops. Otherwise the rest of the group entries are searched next. If the subject has multiple groups, the group entries are evaluated as presented in the Multiple Group Evaluation section, otherwise they are searched in order as the user entries are. Finally, if no user or group entries were found to match the effective identity of the subject, access is determined based on the <B>other entry.</B><p>
For the following discussion on the ordering of ACL entries9 it will be assumed that the classes will be ordered and follow this most-to-least specific regime.<p>
<H2><A NAME="HDR8.2 3 36">8.2 User-Defined Ordering</A></H2>
In this method, entries are considered according to the ordering given by the user. The first entry as specified by the user is considered first, the second entry next, and soon.<p>
As long as the "user, then group, then other" order is followed, the only security relevant problem with this method occurs when evaluating group entries with multiple groups. If a user is a member of multiple groups and matches more than one of the group entries, the resulting access may be dependent upon the ordering of the group entries. See the Multiple Group Evaluation section for various possibilities. Unless all matching group entries are considered when determining access, the burden is placed on the user to correctly order the group entries.<p>
This method may appear to be more convenient for users, however, it may require the user to have extensive knowledge of group membership. Additionally, it does not allow for very efficient access evaluation as discussed in the following section.<p>
<H2><A NAME="HDR8.3 3 36">8.3 System-Defined Ordering</A></H2>
In this method, entries are considered according to a system-defined ordering. Although the user does not have the flexibility of choosing an arbitrary order of entries, a system-defined ordering gives consistency to ACLs throughout the system and may also allow for quicker access determination.<p>
The system may use any of a variety of ordering methods, two of which are alphabetical ordering by user or group name and numeric ordering by user or group ID. An ordering of lowest to highest UID or GID, or vice-versa, is recommended as it provides an efficient way to check for redundant entries. Redundant entries should not be allowed in an ACL.<p>
It is important to mention that actual sorting need not be done by the kernel itself as long as the kernel enforces the specified ordering. In other words, the sorting can be achieved through the use of library routines. The ACL commands would automatically use the library sorting routines and users would also be encouraged to do so when writing their own programs which manipulate ACLs. When an ACL passed to the kernel, the kernel verifies that the entries are sorted or else a failure will occur. In this manner, efficiency is achieved while still enforcing a system-defined ordering.<p>
This alternative is simple. reduces the possibility of user error, and allows for more efficient access determination.<p>
<H2><A NAME="HDR8.4 3 37">8.4 Multiple Group Evaluation</A></H2>
When a subject is a member of multiple groups, there are several ways the group entries may be evaluated, regardless of the ordering of the entries.<p>
The following methods may be used to evaluate access when multiple groups are used:<p>
The first entry which matches one of the subject's groups might be used to determine access. While this is an efficient method, it does not take notice of the possibility of other groups granting access.<p>
The entry which matches one of the subject's groups and grants the least access might be used. This method does not recognize the possibility that all the groups together might grant or deny the desired access.<p>
The entry which matches one of the subject's groups and grants the most access might be used. This method also does not recognize the possibility that all the groups together might grant or deny access.<p>
ANDing the permissions of all the entries which match groups of the subject is another possible method. This approach may be considered too restrictive, since even one entry which grants access may be overruled by other entries which deny access.<p>
ORing the permissions of all the entries which match groups of the subject is also a possibility. This method may be considered too permissive, since the maximum permissions allowed by all the matching entries taken together is the result. However, the same effect can be achieved currently, through the user simply invoking the newgrp command to change to the group with the d1esired access or by opening the same file twice from two different groups which together provide the desired access.<p>
<H2><A NAME="HDR8.5 3 38">8.5 Recommendation</A></H2>
A system-defined ordering which evaluates ACLs entries from most-to-least specific is recommended. Since multiple groups were designed to be permissive and permissive results can be achieved through other means anyway, the method which ORs the permissions of all matching group entries is recommended for systems implementing multiple groups.<p>
Concern has been expressed that this scheme violates the wording in the TCSEC, for DAC at class B3. The TCSEC states: Furthermore, for each such named object, it shall be possible to specify a list of named individuals and a list of groups of named individuals for which no access to the object is to be given. The ORing of groups, however, does not present a conflict with the class B3 DAC requirement, as it still allows the user to specify groups that shall have no access.<p>
<HR>
<H1><A NAME="HDR9 2 38">9. DAC Compatibility</A></H1>
Designing an ACL mechanism requires that attention be given to the use of system calls which check or modify the existing DAC mechanisms, and to the additional use of ACL mechanisms in system calls. The classes of DAC mechanisms which return or change the value of the discretionary access control information are those mechanisms which: change ownership of an object, change the file permission bits, create objects, access object attributes. and access object data. Each of these classes will now be examined and a determination will be made of what changes, if any, are required for inclusion in a system with ACLs. For each class, we provide alternative solutions and identify the preferred choice.<p>
<H2><A NAME="HDR9.1 3 39">9.1 Changing Ownership Of An Object</A></H2>
Mechanisms which change ownership of an object (e.g., <B>chown, msgctl, semctl, shmctl</B>) could create a new user or group entry for the object owner or group, with the same access permissions as the original entry for the object owner or group. The original entry would become an additional user or group entry. The problem with this alternative is that by leaving the original entry for the object owner or group behind as an additional user or group entry, the mechanism will always create an ACL for an object which did not have one to begin with.<p>
The preferred alternative is for these calls to suffer no additional side effects due to the presence of ACLs. This can be achieved by not storing explicit IDs in the owner and owning group ACL entries. An advantage of this alternative is that the ACL entries for object owner and object owning group can be readily distinguished syntactically from the other user and group entries.<p>
<H2><A NAME="HDR9.2 3 39">9.2 Changing The File Permission Bits</A></H2>
Mechanisms which change the file permission bits (e.g., <B>chmod, msgctl, semctl, shmctl</B>) might be changed so that they fail, or partially fail, when presented with an object that has an ACL.<p>
Complete failure is a poor alternative since these mechanisms change the file mode, not just the file permission bits. For example, a program should be able to do a legitimate operation such as changing the setgid bit on any file.<p>
Partial failure means that these mechanisms would make the requested changes but return an error value different from -1. This is a poor alternative for two reasons: it does not make good sense to succeed while returning failure. and programs often do not differentiate between error return values.<p>
Other alternatives attempt to minimize surprises to the caller by changing ACL entries. The first of these alternatives is to mask the access permissions in all the object's additional entries. Access permissions for entries with specific user and specific group are ANDed with the supplied user and group access permissions. Access permissions for entries with only a specific user are ANDed with supplied permissions for the user, and permissions for entries with only a specific group are ANDed with supplied permissions for the group. While this meets POSIX requirements, programs that wish to change only the file mode (non-access) bits will have the masking occur as an undesirable side effect. Another alternative is to disable the additional entries. This implicitly requires a new mechanism to enable entries that have been disabled. POSIX requirements are also satisfied by this alternative, but the same problems exist as in the previous alternative; programs using these mechanisms to change the non-access file mode bits will have entries disabled as an undesirable side effect. Still another alternative is to delete the additional entries. This has similar advantages and disadvantages as ACL entry disabling. It is simpler since there is no need for an ACL entry enabling mechanism. Information given by the user, however, is deleted without warning.<p>
The preferred method is to make no changes to these mechanisms. The mechanisms will affect only file permission bits and ACL entries for the object owner or group. While this does not provide non-ACL cognizant programs with expected results for operations on objects with ACLs, it is not perceived as a serious problem. This alternative is consistent with the preferred alternative for mechanisms which access object attributes as well (see below).<p>
<H2><A NAME="HDR9.3 3 40">9.3 Creating Objects</A></H2>
Mechanisms which create or truncate objects (e.g., <B>creat, open, mkfifo, mkdir, msgget, semget, shmget</B>) should work as they currently do, except that they may create an ACL as part of the default ACL mechanism. Please refer to the section on default ACLs for more information. Note that default protection on newly-created objects will be accomplished via the umask and/or default ACLs.<p>
It may also be desirable to add other types of ACL features to mechanisms. For example, one might wish to add the capability during file creation to adopt a specific ACL. For changes of this type, parameters of existing mechanisms should not be changed, and new parameters should not be added. New mechanisms should be created which make use of existing ones. For example. <B>creat</B> may need to be modified to take ACLs into account, but the parameter list should not change. Instead of adding an ACL parameter to <B>creat</B>, a new system call (i.e. with some other name) should be used. which takes the ACL as a parameter and then uses <B>creat</B>.<p>
<H2><A NAME="HDR9.4 3 40">9.4 Accessing Object Attributes</A></H2>
Mechanisms which access object attributes (e.g. <B>stat, msgctl, semctl, shmctl</B>) could be modified to fail when applied to an object with an ACL. This is an unacceptable alternative since these mechanisms return more information than simply the file mode. Thus. non-functionality would require a new mechanism to return the additional information for objects with ACLs.</B><p>
Another alternative is to find all the entries in the ACL that apply to the user-ID and group-ID of the subject, just like a permissive access check. Then OR all the associated permissions together, and return the results in the appropriate file permission bits (user, group, and other). While this alternative integrates the idea of ACLs into mechanisms that access object attributes9 the context of the mechanisms affects the result returned to the point where the meaning of what the mechanisms return is somewhat clouded.<p>
The preferred alternative is to make no changes to these mechanisms. The mechanisms will continue to return the file permission bits as if ACLs did not exist. Another mechanism must then be used to find out if the file has an ACL, and if so, what its entries are. While this alternative does not provide all information to subjects that don't know about ACLs, it does not change the current behavior of these mechanisms.<p>
<H2><A NAME="HDR9.5 3 41">9.5 Accessing Object Data</A></H2>
There are a number of system calls which will need to have AFL functionality added to them (i.e., for access checking). These calls include all those taking file system object names as parameters, as well as those IPC mechanisms which perform access checks. Examples of some of these calls are: <B>open, msgsnd, msgrcv, semop,</B> and <B>shmat</B>.<p>
It is also important for portability that programs use the available access control mechanisms in an appropriate manner, so that the security policy is interpreted correctly. For instance, at the system call level, the permission information returned by the use of <B>stat</B> may not be sufficient to determine allowed access; other information such as ACL contents may have to be evaluated as well.<p>
<H2><A NAME="HDR9.6 3 41">9.6 Recommendation</A></H2>
The following is a summary of the preferred alternatives stated in this section. Regarding compatibility with existing DAC mechanisms that either 1) change ownership or group of an object. 2) change file permission bits, or 3) access object attributes should remain unchanged and not affect an existing ACL on the object or create an ACL where one did not exist before.<p>
Regarding the addition of ACL functionality, existing mechanisms should not be changed, and new parameters should not be added. Instead, new mechanisms should be created which make use of existing ones.<p>
<HR>
<H1><A NAME="HDR10 2 42">10. ACL System Calls And Commands</A></H1>
This issue addresses what the naming conventions and functionality for ACL system calls and commands should be.<p>
For system calls, there are at least two alternative types of designs. Each depends on how the ACL is viewed. In one approach, the ACL is a series of independent records which can be individually manipulated using calls similar to <B>open, read, write,</B> and <B>close</B>. This approach has a nice parallel to the way files are read and written, but may be viewed as overly complicated given the relative infrequency of ACL modification. In the other approach. the ACL is considered a single unit and is not changed record-by-record, but instead always manipulated as a whole. This approach uses a "get" and "set" concept for ACL operations, where an ACL, as a whole, is retrieved, modified locally, and then replaced [3]. This approach is simple and reflects the growing trend towards get/set type operations.<p>
It may also be reasonable to extend the "get" and "set" concept to apply to default ACLs as well as to the ACL associated with an object. This is a natural extension of the way ACLs would be manipulated, and default ACL operations may be easily added to the recommended system call interface described below.<p>
There are also two possible methods for implementing these calls. One option is to use separate system calls for each of the ACL operations (i.e., getacl, setacl). The other option is to have one ACL system call that can be invoked with a number of command arguments indicating the desired ACL operation [3]. An example of a useful additional command argument is one that would return the number of entries in the ACL. This method conserves the number of system calls, and provides the flexibility to add ACL commands via command arguments. Additionally, using this method, designers are free to implement library functions based on the system call with particular command flags.<p>
For commands, the same issues apply as for system calls. In a system with ACLs, however, there will be a need for commands to not only manipulate ACLs, but also to show and manipulate all discretionary access control information. These commands should include. at a minimum:<p>
<UL>
<LI>command(s) to retrieve and set file permission and mode bits (ls, chmod)<p>
<LI>command(s) to retrieve and set ACL information (new)<p>
<LI>command(s) to retrieve effective discretionary access to files (new)<p>
</UL>
In addition, there may be useful features to add to existing utilities (e.g., the ability to find a file according to its ACL [12]) so that they might be able to conform to the enhanced DAC mechanisms.<p>
<H2><A NAME="HDR10.1 3 43">10.1 Recommendation</A></H2>
For the ACL system call interface, get/set ACL type operations should be used9 and should be implemented with a unified system call with command arguments used to implement the various operations. For commands. the names <B>getacl</B> and <B>setacl</B> are recommended since they follow from the get/set concept.<p>
<HR>
<H1><A NAME="HDR11 2 43">11. Named ACLs</A></H1>
A named ACL, as described in A Guide to Understanding Discretionary Access Control in Trusted Systems [2], is an ACL that can be shared or referred to by name. They may be implemented in one of two ways; either as a template copied into a user's ACL or shared through a pointer from the user's ACL space (shared ACL).<p>
A change to a shared ACL results in a change to the discretionary access on all objects using this ACL. This result may be considered to be a side-effect or a desired feature depending on the circumstance. Additionally, it may be difficult to determine which objects are sharing a specific named ACL, and a user may mistakenly grant access to an object that was not intended.<p>
Another problem with named ACLs is that as objects they may themselves be required to contain discretionary access controls. This suggests the idea of recursive ACLs, a situation to be avoided.<p>
<H2><A NAME="HDR11.1 3 43">11.1 Recommendation</A></H2>
Named ACLs need not be supported. but a system that does should be no less secure or less flexible than one that does not. Absolute flexibility of ACLs can be achieved, however, through the use of default ACLs as discussed in the following section. There is no strong case one way or the other for named ACLs. There are advantages and disadvantages to both alternatives and it would really depend on the environment as to whether named ACLs would be of any benefit.<p>
<H1><A NAME="HDR12 2 44">12 Default ACLs</A></H1>
When considering ACLs, an issue arises as to whether a predesignated set of ACL entries should be assigned to an object automatically at the time of creation. The following alternatives present the possible ways to address this issue.<p>
<H2><A NAME="HDR12.1 3 44">12.1 No Default ACLs</A></H2>
In this approach, no ACL is assigned at object creation time. The process umask will limit the file permission bits, as it currently does, to provide some default protection on an object.<p>
While this alternative maintains compatibility with existing programs, it is not a very practical solution. Depending on the relationship of the file permission bits and the ACL, the absence of default ACLs may not make sense. For instance, in a pure ACL implementation, the absence of default ACLs would result in no initial protection on newly created files. Additionally, this alternative would not encourage the use of ACLs by new programs, and would prevent ACL creation by old programs. ACLs could not propagate through the system and hence their usability would be lost.<p>
<H2><A NAME="HDR12.2 3 44">12.2 Require Default ACLs</A></H2>
In this approach, an ACL would always be assigned at object creation time. This would allow for initial finer grained control on an object.<p>
Requiring default ACLs may cause incompatibilities for an old program that only looks at the file permission bits when it creates an object. Also, for many users, the umask may be a sufficient tool for limiting the permissions on an object when it is created. The main advantage of requiring default ACLs is that the usability of ACLs is greatly improved. Additionally, since an ACL is associated with an object in a single atomic operation, the possibility of a temporarily insecure state is avoided.<p>
<H2><A NAME="HDR12.3 3 45">12.3 Provide Default ACLs</A></H2>
A mechanism is provided to put default ACLs on new objects. However9 not all new objects need to have default ACLs. This alternative allows specification of a default ACL, giving a finer granularity of access control than that provided by the file permission bits, and, at the same time allows, where desired, compatibility with existing programs.<p>
<H2><A NAME="HDR12.4 3 45">12.4 Recommendation</A></H2>
<B></B>Providing default ACLs and mechanisms to specify whether or not to use them is the best solution. This allows both classes of users, those who want default ACLs and those who do not (even those who want no ACLs at all), the flexibility to specify the scheme that they find most appropriate. Although in many cases the process umask would be sufficient to assign default permissions, systems and/or users making explicit use of ACLs will desire default ACLs. The default ACL scheme used should be straightforward to the user and should sensibly interact with the existing DAC mechanisms, including the umask mechanism. Note that even if an object is created with no default ACL, ACL entries may still be added to the object.<p>
This section has really only addressed default ACLs on file system objects. IPC objects are not part of the file system name space, and therefore require further consideration. IPC objects are relatively short lived. and are generally not manipulated by users at the command level as are files. Based on these characteristics default ACLs on IPC objects are probably not needed, and their use is not recommended.<p>
<HR>
<H1><A NAME="HDR13 2 45">13. Location Of Default ACLs</A></H1>
Consider the following possibilities for the origination of the default ACL.<p>
<H2><A NAME="HDR13.1 3 45">13.1 System Wide</A></H2>
In this approach, one specific default ACL is assigned to any object created on the system by any subject. This is a very inflexible solution and misses the intent that discretionary access be set at the discretion of the user.<p>
<H2><A NAME="HDR13.2 3 46">13.2 Per Process</A></H2>
In this approach, each user process defines a default ACL, similar to the umask currently used. This is a somewhat restrictive approach since this allows the user to set only a single set of defaults for all files created. It is likely that a user will wish to associate different default ACLs with files created for different projects. Additionally, the default ACL entries would have to be stored in the process area. The amount of process space required to hold the entries would vary based on the number of entries.<p>
<H2><A NAME="HDR13.3 3 46">13.3 Per GID Of Created File</A></H2>
A default ACL could be associated with each GID. If GIDs are viewed as project identifiers, the effect is to associate a unique default ACL within each project subtree of the file system hierarchy. Further, in some UNIX Systems, where GIDs propagate to newly created objects based on the GID of the creating directory (rather than upon that of the creating subject), default protection very naturally distributes across the file system. However this variant imposes a somewhat restrictive viewpoint on the utility of groups.<p>
<H2><A NAME="HDR13.4 3 46">13.4 Per Directory</A></H2>
This approach would allow the object's default ACL to originate from the containing directory of the object. A directory would contain both an ACL to be used for access checking and a default ACL to be used when a new object is created in the directory. All objects created in the directory would be assigned the default ACL. Newly created subdirectories would inherit the default ACL of the parent directory. In this manner, the default will propagate down through the file system structure resulting in much duplication of ACLs, possibly using much space. However, the utilization of such space is a small price to pay for enhanced security and usability, so the default should probably continue to propagate until the user takes some explicit action to stop the propagation.<p>
<H2><A NAME="HDR13.5 3 46">13.5 Recommendation</A></H2>
A user typically arranges objects per directory representing project work or areas of interest. Since it is desirable, then, for similar objects to contain the same ACL, the per-directory approach becomes the preferred mechanism. Newly-created subdirectories should inherit the default ACL of the parent directory, so that defaults are propagated down the file system, unless explicitly turned off.<p>
<HR>
<H1><A NAME="HDR14 2 47">14. Interaction Of Default ACL Entries At File Creation</A></H1>
Currently, when a file is created a user can specify its initial permissions, however the access can be further restricted by the umask mechanism. The umask specifies the default protection bit settings when a file is created. Any bits set in the umask will be cleared in the bit settings on the newly created file. It is important, then, to consider how the default permission bit settings should interact with the entries in a default ACL.<p>
Consider the following options in the context of masking the ACL entries by the file group class permission bits as recommended in the ACL Evaluation section. Also note that these options are discussed with respect; to the ACL entry types as described in the ACL Entry Type and Format section. Additional mechanisms in the ACL which allow direct modification of the file group class permission bits at file creation are not precluded.<p>
<H2><A NAME="HDR14.1 3 47">14.1 OR File Group Class Permission Bits</A></H2>
Add the default entries to the file and change the file group class permission bits to reflect the maximum permissions allowed in the ACL. This could result in more permission than was specified in the creation call. It is not reasonable to assume that the default permission bit settings can be ignored and completely overridden by the ACL. For example, if a default entry exists for user "fred" with the specified permissions of "rwx" but the file is not executable, then this permission should not be given.<p>
<H2><A NAME="HDR14.2 3 47">14.2 AND File Group Class Permission Bits</A></H2>
Add the default entries to the file but change the permissions of the ACL entries so that they are no greater than the file group class permission bits. This is a reasonable alternative, but it may present a compatibility problem for some applications. An example of this problem would be when a C compiler creates a file. The file would not originally be created with execute permission, therefore no ACL entries on the file (which were default entries copied from the directory) would have execute permission. The last step for the compiler would be to make the file executable, however at this point, execute permission' which may have been specified in the default ACL entry is lost.<p>
<H2><A NAME="HDR14.3 3 48">14.3 No Change To File Group Class Permission Bits</A></H2>
Add the default entries to the file but do not change the file group class permission bits. This may result in ACL entries which are restricted by the file group class permission bits.<p>
<H2><A NAME="HDR14.4 3 48">14.4 Recommendation</A></H2>
The No Change To File Group Class Permission Bits is recommended since it is a reasonable alternative which does not present any problems of compatibility for some applications.<p>
<HR>
<H1><A NAME="HDR15 2 48">15. Summary</A></H1>
This document has provided an analysis of key issues involved in extending the discretionary access control in the UNIX system. For each of the issues identified, the paper has suggested alternative solutions, discussed the pros and cons of each, and then provided a recommendation.<p>
The following is a review of some of the important recommendations presented in the paper. An access control list mechanism was chosen to extend the current DAC mechanism. When considering the types of access provided in the UNIX system, additional access modes need not be defined, however they should also not be precluded. The recommended ACL entry type was that of user or group entries. The main advantages of this solution are conformance with the UNIX system method of identification through either the user-ID or the group-ID, and simplicity for the user. The method in which file protection bits and ACLs interact is a very important and complex issue given the conflicting goals of security and compatibility. The recommendation of masking the ACL entries by the group field of the protection bits was chosen as the most accommodating solution considering these goals. A system defined ordering of the ACL entries was preferred and it was recommended that the access allowed for a user in multiple groups should be the sum of all access allowed for each group represented in the ACL. Considering other multiple group issues9 it was recommended to provide the multiple concurrent group capability along with some method of subsetting. It was also recommended that default ACLs be provided and that they originate from the parent directory of the newly created object.<p>
It is important to note that although these and other specific recommendations were given, it is certainly possible to design an acceptable class B3, POSIX-compliant UNIX system following some of the other alternatives. In fact, there are issues where the recommended solution may not be superior to another alternative and the designer should consider his/her own specific requirements when making a choice in those areas. It must also be pointed out that building a system following all the recommendations presented in this paper will not guarantee a full class B3 system. There are many additional class B3 requirements that go beyond the interface specification.<p>
<HR>
<H1 ALIGN=CENTER><A NAME="HDR 2 49"> APPENDIX: Worked Example</A></H1>
<H1>A.1 Introduction and Overview</H1></UL>
This worked example describes one particular Implementation following the recommendations in the TRUSIX rationale.<p>
<H2>A.1.1 Discretionary Access Control</H2>
Discretionary access control (DAC) provides for the controlled sharing of objects (e.g., files, IPC objects) between subjects (e.g., processes). With discretionary access control, the owner of an object can grant permissions to other users. The discretionary access control mechanism uses object owner, object group, file permission bits (nine permission bits) and the access control list (ACL) of an object to determine the discretionary access to the object.<p>
This document will detail the DAC interfaces and their run-time behavior.<p>
The goals of this ACL mechanism were:<p>
<UL>
<LI>compatibility with the current UNIX System DAC mechanism and POSIX
 P1003.1
<LI>user command interfaces that are easy to use and understand
<UL>
<LI>adhere to the "principle of least astonishment"
</UL>
<LI>interfaces should continue to work as expected
<UL>
<LI>chmod 000 file - no access to file
<LI>chmod 700 file - only owner access to file
<LI>chmod 444 file - denies write and execute access to file
</UL>
</UL>
In addition, intermixing use of the existing and new DAC commands should give reasonable results. For instance chmod should not fail due to ACLs, and when <EM>chmod x file</EM> is executed (<EM>x</EM> is an octal permission) <EM>ls -l</EM> displays <EM>x</EM> as the permissions. The current output of <EM>ls -l</EM> displays the file permission bits as a constant width set of nine characters:<p>
<DL>
<DD>rwxrwxrwx
</DL>
<P>
However, an ACL, which consists of one or more <B>user</B> entries, one or more <B>group</B> entries, one <B>class</B> entry, and one <B>other</B> entry, is not a constant length (in the following example, * indicates zero or more occurrences of the preceding entry type):<p>
<DL>
<DD># file: filename
<DD># owner: uid
<DD>#group:gid
<DD><B>user</B>::rwx
<DD><B>user</B>:uid:rwx
<DD>*
<DD><B>group</B>::rwx
<DD><B>group</B>:gid:rwx
<DD>*
<DD><B>class</B>:rwx
</DL>
The file permission bits shown by the Is command have the following meaning: (note the following "class" definitions are from the IEEE POSIX Std 1003.1-1988):<p>
<DL>
<DD> 1. the first 3 bits (high order) represent the file owner class and
 define the permissions for the object owner,<p>
<DD> 2. the middle 3 bits (commonly called the group permission bits), represent the file group class. This class includes the owning group of the file and will be extended to include additional <B>user</B> and additional <B>group</B> ACL entries,<p>
<DD> 3. the last 3 bits (low order) represent the file other class and define the permissions for other (those that did not fall into 1 or 2 above).<p>
</DL>
These nine bits indicate the maximum discretionary permissions for an object. The actual permissions may always be less than indicated. For instance, the permission may indicate write access on an object by a specific subject, but the file system may be mounted read only. If an ACL mechanism is used these bits will continue to indicate the maximum discretionary permissions for the object and the ACL may further restrict permissions.<p>
There is a direct mapping between the ACL and the file permission bits. Specifically, the file owner class permission bits will always be equal to the permissions of the ACL entry for the object owner (they may be the same bits depending upon the implementation). Additionally, the file other class permission bits will always be equal to the ACL <B>other</B> entry permissions. And the file group class permission bits will always be equal to the ACL <B>class</B> entry permissions. Typically, the file group class permission bits are set to the maximum permissions allowed to the additional <B>user</B> entries, the owning <B>group</B> entry, and the additional <B>group</B> entries.<p>
Whenever a file is created on a file system that supports ACLs, the ACL will contain a <B>user</B> entry for the object owner, a <B>group</B> entry for the object owning group, a <B>class</B> entry for the file group class permissions, and an <B>other</B> entry for the rest of the world. For compatibility with the current mechanism, if the ACL contains no additional <B>user</B> or additional <B>group</B> entries, the permissions in the <B>group</B> entry for the object owning group and the <B>class</B> entry must be the same.</B><p>
<H2>A.1.2 Use of Access Control Lists</H2>
The use of DAC with ACLs will be explained by comparing it to how a user of a non-ACL supporting UNIX System (as currently exists) would use DAC. To use the current DAC mechanism a user usually first executes ls -l and based on the output decides what the permissions must be changed to. in order to allow the desired access (for example the user may want to make the file executable, or only allow the owner to have write permission).<p>
EXAMPLE:<p>
$ ls -l foo<BR>
-rw-rw-rw- 1 craig demo 53 Mar 6 17:37 foo<P>
$ chmod 600 foo<P>
$ ls -l foo<BR>
-rw------- 1 craig demo 53 Mar 6 17:37 foo<P>
In the new DAC mechanism, using a pure ACL, there will be two new commands <EM>getacl</EM> and <EM>setacl</EM> (there will be a new function, <EM>acl</EM>, for which these commands provide a user interface). The <EM>getacl</EM> command will be used to display the ACL and the <EM>setacl</EM> command will be used to change the ACL.<p>
These commands will be used in much the same way that Is and chmod are used. A user would first execute getacl to look at the ACL and then use setacl to make the desired changes. Because the ACL is not a fixed size, it may be difficult to manipulate. In order to simplify the use of ACLs the following example shows how the ACL may be easily manipulated using a text editor to give greater flexibility (note that changes may also be specified on the setacl command line).<p>
EXAMPLE:<p>
#the output of getacl is redirected to the file tmp<BR>
$ getacl bar &gt; tmp<P>
#the file tmp is edited and the line in italics is inserted<BR>
$ vi tmp<BR>
# file: bar<BR>
# owner: craig<BR>
# group: demo<BR>
user::rw-<BR>
group::rw-<BR>
group:guest:r--<BR>
class:rw-<BR>
other:rw-<P>
#setacl is executed and the contents of the file tmp become the new ACL for bar<BR>
$ setacl -f tmp bar<P>
#the output from getacl for the file bar is displayed<BR>
$ getacl bar<BR>
# file: bar<BR>
# owner: craig<BR>
# group: demo<BR>
user::rw-<BR>
group::rw-<BR>
group:guest:r--<BR>
class:rw-<BR>
other:rw-<P>
<H2>A.1.3 Structure of Access Control Lists</H2>
The ACL consists of the following types of entries, which must be in the following order:<p>
<DL>
<DD> 1. <B>user</B> entry - This type of entry contains a user ID and the permissions associated with it. There must always exist one entry of this type, which will represent the object owner, and will be denoted by a null (unspecified) user ID. There may be additional <B>user</B> entries specified; however, no two additional <B>user</B> entries will have the same user ID and there may not be any additional entries with a null user ID. The term "additional <B>user</B> entries" will be used to indicate all user entries except the entry for the object owner.<P>
<DD>2. <B>group</B> entry - This type of entry contains a group ID and the permissions associated with it. There must always exist one entry of this type, which will represent the object owning group, and will be denoted by a null (unspecified) group ID. There may be additional <B>group</B> entries specified; however. no two additional <B>group</B> entries may have the same group ID and there may not be any additional entries with a null group ID. The term "additional <B>group</B> entries" will be used to indicate all <B>group</B> entries except the entry for the object owning group.<P>
<DD>3. <B>class</B> entry - This type of entry contains the maximum permissions granted to the file group class. There is exactly one of these entries in an ACL.<p>
<DD>4. <B>other</B> entry - This type of entry contains the permissions granted to a subject if none of the above entries have been matched. There is exactly one of these entries in an ACL.<p>
<DD>5. <B>default</B> entry - This type of entry may only exist on a directory.  These entries are similar to the entries described above, except that they are never used in an access check, but are used to indicate the non-default ACL entries that should be added to a file created within the directory. Default entries are optional, but no two default entries may have the same type and ID.<P>
</DL>
Within each category the entries must be ordered as follows:<p>
Entries in the <B>user</B> category shall be sorted numerically by user ID from lowest to highest, except for the object owner entry which always precedes all other user entries.<p>
Entries in the <B>group</B> category shall be sorted numerically by group ID from lowest to highest, except for the object owning group entry, which always precedes all other group entries.<p>
Entries in the <B>default:user</B> category shall be sorted numerically by user ID from lowest to highest, except for the default object owner entry, which always precedes all other default user entries. Entries in the <B>default:group</B> category shall be sorted numerically by group ID from lowest to highest, except for the default object owning group entry, which always precedes all other default group entries. The proper ordering of entries required by the acl function can be obtained by the use of the aclsort function. ACL entries given as input to the setacl command need not be sorted; the sorting will be performed by the setacl command.<p>
The permissions that may be specified in an ACL entry are read(r), write(w), and execute/search(x).<p>
When the <EM>setacl</EM> command is executed, the file owner class permission bits will be set to the permissions specified for the owner and the file other class permission bits will be set to the permissions specified for <B>other</B>. As an option, the file group class permission bits will be manipulated such that they reflect the maximum permission that the ACL permits to members of the file group class (any ACL entry other than the object owner or other). Otherwise, the file group class permission bits will be set to the permissions specified by the class entry. Therefore, if the file group class only allows read permission then additional user entries and any group entries in the ACL will not grant write or execute permission.<p>
This ACL scheme supports finer discretionary access controls than the current mechanism, while maintaining compatibility with the current permissions mechanism. The DAC information may be changed in one atomic operation, avoiding the possibility of an intermediate insecure state. Finer controls can be specified via the ACL, including explicit specification of users disallowed any access to the object. Additionally, the file permission bits provide a summary of all access rights.<p>
<B>Rationale:</B> The ACL scheme described here will allow entries to be either permissive or restrictive. In general, an entry that results in less permission than the file other class permissions would grant would be considered restrictive. An entry that results in more permission than the file other class permissions would grant would be considered permissive. In the event that a file with an ACL is exported to a non-ACL system, the loss of permissive entries would not present a security problem; however, the absence of support for restrictive entries may allow a process to have permission that it would not have been granted on a system with ACLs. This behavior must be described in the documentation.<p>
<H2>A.1.4 Discretionary Access Check Algorithm</H2>
A process may request read, write, or execute/search access permissions to a file. Each access mode is logically checked separately using the following algorithm. The process request is granted if all individually requested modes are granted. Otherwise, the access request is denied.<p>
Note, this is a logical description of the access check. The physical code sequence may be different for better performance. <p>
Discretionary Access Check Algorithm:<p>
<DL>
<DD>I. File Owner Class: If the effective user ID of the process matches the
 user ID of the owner of the file, the process is in the file owner class.
 If the requested access mode bit is set in the file owner class
 permission bits, this access mode is granted. Otherwise, access is
 denied.<p>
 Note, the <B>user</B> ACL entry for the object owner matches the file owner
 <B>class</B> permission bits.<p>
<DD>II. File Group Class: If the process is not in the file owner class and if
 the effective user ID of the process matches the user ID of an
 additional <B>user</B> ACL entry or the effective group ID or any of the
 supplementary group IDs of the process matches the group ID of any <B>group</B>
 ACL entry, the process is in the file group class. If the process
 matched an additional <B>user</B> ACL entry, only that entry is used as the
 matching ACL entry; otherwise, the matching <B>group</B> ACL entry or entries
 are used. If the requested access mode bit is set in the file group
 class permission bits and is set in a matching ACL entry, this access
 mode is granted. Otherwise, access is denied.<P>
 Note, the permissions of the additional <B>user</B> or <B>group</B> ACL entries
 further restrict the access specified by the file group class permission
 bits. Also, the class ACL entry matches the file group <B>class</B>
 permission bits.<p>
<DD>III. File Other Class: If the process is not in the file owner class or
 file group class, the process is in the file other class. If the
 requested access mode bit is set in the file other class permission
 bits, this access mode is granted. Otherwise, access is denied.<p>
 Note, the <B>other</B> ACL entry matches the file other class permission bits.<P>
</DL>
The following examples show ACL use and the results of applying current and new DAC commands.<p>
EXAMPLE 1:<p>
# create file foo<BR>
$ &gt; foo<p>
#execute ls -l and getacl on the file foo<BR>
$ ls -l foo<BR>
-rw-r--r-- 1 craig demo 0 Mar 620:27 foo<p>
$ getacl foo<BR>
# file: foo<BR>
# owner: Craig<BR>
# group: demo<BR>
user::rw-<BR>
group::r--<BR>
class:r--<BR>
other:r---<P>
EXAMPLE 2:<p>
#execute getacl and Is -I on the file, run.sh, with added ACL entries<BR>
$ ls -I run.sh<BR>
-rwxr-xr-x+ 1 Craig demo 73 Mar 620:27 run.sh<p>
$ getacl run.sh<BR>
# file: run.sh<BR>
# owner: Craig<BR>
# group: demo<BR>
user::rwx<BR>
user:fred:r-x<BR>
user:larry:--x<BR>
group::r-x<BR>
group:guest:---<BR>
class:r-x<BR>
other:r-x<p>
EXAMPLE 3:<p>
#use the chmod command on a file with an ACL<BR>
#use getacl to report both the ACL entries and the effective permissions<BR>
$ chmod 644 run.sh<P>
$ ls -l run.sh<BR>
-rw-r--r--+ 1 craig demo 73 Mar 620:27 run.sh<p>
$ getacl run.sh<BR>
# file: run.sh<BR>
# owner: craig<BR>
#group: demo<BR>
user::rw-<BR>
user:fred:r-x #effective:r--<BR>
user:larry:--x #effective:---<BR>
group::r-x #effective:r--<BR>
group guest:---<BR>
class:r--<BR>
other:r--<p>
<H2>A.1.5 File Object Creation</H2>
When a new object (regular files, special files, directories, named pipes) is created in the file system, there are several important attributes that must be initialized. These are the user ID of the owner of the file, the group ID associated with the file, the file permission bits, and the ACL.<p>
The user ID of the file is set to the effective user ID of the invoking process. The group ID of the file depends upon the mode of the containing directory. If the S_ISGID bit is not set on the directory, the group ID of the file is set to the effective group ID of the invoking process. If the S_ISGID bit is set on the directory, the group ID of the file is set to the group ID of the containing directory.<p>
Each function that creates a new file supplies an initial value for the file permission bits. This initial value is then merged with the file mode creation mask (umask) of the invoking process and with any default ACL entries of the containing directory to form the file permission bits and ACL of the new file.<p>
Although in many cases the process <B>umask</B> is sufficient to assign default permissions, users making explicit use of ACLs may desire default ACLs. The default ACL scheme must sensibly interact with the existing DAC mechanism, including umask.<p>
The default ACL entries specify permissions for users and/or groups and/or others, that will be assigned to a new file. These default ACL entries are associated with a directory. Note, an ACL on a directory may contain entries that control access to the directory and entries (defaults) used for new file creation in that directory.<p>
The process of creating the file permission bits and the ACL for the new file is called "ACL Merge". First, any mode parameter is transformed into the equivalent ACL form. For example, the mode 0664 is equivalent to user::rw-, group::rw-, class:rw-, other:r--. Also, the complement of the umask is used to obtain the equivalent ACL. Thus, the umask 022 is equivalent to user::rwx, group::r-x, class:r-x, other:r-x.<p>
Two ACLs are merged by first logically sorting both ACLs into one ACL. Then any pair of matching entries are replaced with an entry that has permissions formed by ANDing the matched entries. Thus a permission is in the merged entry only if it was previously in both entries.<p>
The first ACL merge is with the initial mode from the file creation function and with the process file mode creation mask. The second ACL merge is with any default entries from the containing directory. The result is the ACL for the new file. The file permission bits are then set from the <B>user, class</B>, and <B>other</B> ACL entries. Note, this may be different from the setacl command with the -r option since this merge does not set the file group class permission bits to the maximum permission of the file group class entries.<p>
Finally, if the new object is a directory, then any default entries from the containing directory are copied to the new ACL. That is, the default ACL entries of the new directory are the same as the default ACL entries of the containing directory.<p>
An example of the ACL merge operation is shown in the following figure:<p>
<B>FIGURE MISSING!</B>
<P>
<H2>A.1.6 IPC Object Creation</H2>
When an IPC object is created (by shmget for shared memory, by semget for semaphores, by msgget for messages), its cuid and uid will be set equal to the effective user ID of the invoking process and its cgid and gid will be set equal to the effective group ID of the invoking process. The initial permissions are set equal to the specified permissions in the flag argument to the *get calls (shmflg, semflg, and msgflg, respectively). Note that default ACLs do not apply to IPC objects, although ACLs may be added explicitly to an IPC object via the <B>aclipc</B> call.<p>
<H2>1.7 Compatibility Requirements</H2>
A user will generally use the current DAC commands (<EM>ls</EM> and <EM>chmod</EM>) or the new DAC commands (<EM>getacl</EM> and <EM>setacl</EM>). However, the use of these commands are likely to still be inter-mixed, and they must all give correct information. The entire interface to the current discretionary access control information must continue to function as it currently does. For example, chmod must still be able to modify the file permission bits and Is must still be able to report them.<p>
Note that although Is will still report these permissions. they will not be the only permissions evaluated during an access check. The output of Is will continue to be the maximum permission that may be granted, but there may be additional discretionary access control information (ACL entries) that was added to the object. In order to indicate that additional entries exist, Is-I will display the character "+" to the right of the current permissions display if an ACL is present. Therefore, when additional discretionary access control information has been added, in the form of ACL entries (as shown in the examples on previous pages), a user will need to use the newly provided command, getacl, to get a full view of the current discretionary access controls in effect. Although chmod will still modify the file permission bits, it will not change any additional discretionary access control information (i .e., ACL entries for additional users and additional groups) added to the object. To change these additional entries if they exist, the user will need to use the setacl command.<p>
When the owner of an object is changed, the result will be identical to the current behavior. If the owner is changed to a user ID for which an additional user entry already exists in the ACL, the additional user entry is not changed but the user entry for the object owner will take precedence during an access check. When the group of an object is changed. the result will be identical to the current behavior. If the group is changed to a group ID for which an additional <B>group</B> entry already exists in the ACL, the additional <B>group</B> entry is not changed but the <B>group</B> entry for the object owning group will take precedence during an access check (except in the case of multiple concurrent groups, where all group entries are given equal treatment).<p>
When the ACL contains no additional <B>user</B> or additional <B>group</B> entries, the permissions in the <B>group</B> entry for the object owning group and in the <B>class</B> entry must be the same. This behavior is the same as the current mechanism since the file permission bits can only specify at most three different permissions.<p>
<H2>1.8 Documentation Requirements</H2>
The ACL mechanism and its proper use must be fully described in the Trusted Facility Manual and manual pages must be created for the Security Features User's Guide and Security Features Programmer's Guide for all new commands and functions.<p>
<HR>
<H1>A.2 Commands and Functions</H1>
<H2>2.1 setacl Command</H2>
DESCRIPION: The setacl command will support the changing of discretionary
 permission information associated with a file. It will allow the file
 owner or a process with appropriate permission or appropriate
 privilege to perform the following functions:<p>
<DL>
<DD>1. replace an entire ACL, including the default ACL entries on a directory,
<DD>2. add, change, or delete an ACL or default ACL entry or entries.
</DL>
<P>
 This command gives the user an interface to a pure ACL mechanism,
 allowing a finer granularity for file access.
 Note that this command only supports the file system objects: e.g.,
 regular files, special files, directories, and named pipes. For
 simplicity, these objects are referred to as "files".<p>
SYNOPSIS:<p>
<DL>
setacl [-r] [ -rn [<B>u</B>[<B>ser</B>]::operm | perm[,]]
<DD>[<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]]
<DD>[<B>g</B>[<B>roup</B>]::operm | perm[,]]
<DD>[<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]]
<DD>[<B>c</B>[<B>lass</B>]:operm | perm[,]]
<DD>[<B>o</B>[<B>ther</B>]:operm | perm[,]]
<DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]::operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]::operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:operm | perm]
<DD>]
<DD>[ -d [<B>u</B>[<B>ser</B>]:uid[,...]][<B>g</B>[<B>roup</B>]:gid[,...]] [<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid[,...]] [<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid[,...]] [<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:[,...]]]
<DD>file ...
</DL>
or<p>
<DL>
setacl [-r] -s <B>u</B>[<B>ser</B>]::operm | perm[,]
<DD>[<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]]
<DD><B>g</B>[<B>roup</B>]::operm | perm[,]
<DD>[<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]]
<DD><B>c</B>[<B>lass</B>]:operm | perm [,]
<DD><B>o</B>[<B>ther</B>]:operm | perm[,]
<DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]::operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]::operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]]
<DD>[<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:operm | perm]
<DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:operm | perm]
<DD>file...
</DL>
or<p>
setacl [-r] -f acl_file file<p>
where:<p>
<DL>
<DD>operm = octal representation of permissions
(Note: for an ACL entry one octal digit is required)<P>
<DD>perm = a permissions string composed of the characters r (read).
w (write), x (execute/search),
 or - (no permission). The permission string must
 be at least 1 character and no more than 3 characters.
 The characters r. w, and x may only be in the string at
 most once. The characters may be in any order within the
 string.<p>
<DD>uid = user identity (i.e., login name or user ID)<P>
<DD>gid = group identity (i.e., group name or group ID)<p>
<DD> When the <B>-f</B> option is specified, it will take the access control
 information stored in the file <EM>acl_file</EM> and assign it to the file <EM>file</EM>.
 See the PROCESSING section below for further information on the format
 of the file <EM>acl_file</EM>.<p>
</DL>
PROCESSING: A unique ACL will exist for each file on the system. There are four types of ACL entries, consisting of <B>user, group, class</B>, and <B>other.</B> The <B>user</B> entry for the file owner, the <B>group</B> entry for the file owning group, the <B>class</B> entry for the file group class, and the entry for <B>other</B> must always be in the ACL.<p>
<DL>
<DD> 1. <B>user</B> entry - This type of entry contains a user ID and the
 associated permissions that will be granted to the user. There must
 always exist one entry of this type, which will represent the
 file owner, and will be denoted by a null (unspecified) user ID.
 There may be additional <B>user</B> entries specified; however each
 entry must specify a unique user ID and there may not be any
 additional entries with a null user ID. If there is a <B>user</B> entry
 with a user ID equal to the file owner the file owner entry will
 take precedence when an access check is performed.<P>
<DD>2. <B>group</B> entry - This type of entry contains a group ID and the<
 associated permissions that will be granted to the group. There must
 always exist one entry of this type, which will represent the file
 owning group, and will be denoted by a null (unspecified) group
 ID. There may be additional <B>group</B> entries specified; however,
 each entry must have a unique group ID and there may not be any
 additional entries with a null group ID.<p>
<DD>3. <B>class</B> entry - This type of entry contains the maximum permissions
 for the file group class. There is exactly one of these entries in
 an ACL.<p>
<DD>4. <B>other</B> entry - This type of entry contains the permissions granted
 to a subject if none of the above entries have been matched. There is
 exactly one of these entries in an ACL.<p>
</DL>
When the <EM>setacl</EM> command is used to change the ACL. it may result in changes to the file permission bits. Specifically. when the <B>user</B> ACL entry for the file owner is modified the file owner class permission bits will be modified. When the <B>class</B> ACL entry is modified, the file group class permission bits will be modified. When the <B>other</B> ACL entry is modified the file other class permission bits will be modified.<p>
When the additional <B>user</B> entries or additional <B>group</B> entries of the ACL are modified, the file group class permission bits may also need to be modified to reflect the maximum permission allowed by these entries.<p>
The <B>-r</B>, recalculate, option will result in the permissions specified in the class entry being ignored and replaced by the maximum permission needed for the file group class. For example, if there are no additional <B>user</B> entries or additional <B>group</B> entries, the permission of the <B>group</B> entry for the file owning group is used for the class entry.<p>
A directory may contain default ACL entries. These entries may be of the type <B>default:user, default:group, default:class</B>, or <B>default:other</B>. For <B>default:user</B> entries, if no user ID is specified, this entry will apply to the file owner permissions. Additional <B>default:user</B> entries must have a unique user ID specified. For <B>default:group</B> entries, if no group ID is specified, this entry will apply to the file owning group permissions. Additional <B>default:group</B> entries must have a unique group ID specified. If there are no additional <B>default:user</B> entries or additional <B>default:group</B> entries, then the permissions of the <B>default:group</B> and the <B>default:class</B> must be the same.<p>
If a file is created in a directory which contains default ACL entries the entries will be added to the newly created file. Note that the default permissions specified for the file owner class, file group class, and file other class will be constrained by the <B>umask</B> and the mode( specified in the file creation call. If default ACL entries are specified for a file which is not a directory the command will fail {11}, see <B>ERRORS AND RETURNS</B>.<p>
With no options and arguments {1}, see <B>ERRORS AND RETURNS</B>. If the MAC or DAC check fails when a request is made to modify the ACL (2), see <B>ERRORS AND RETURNS</B>. If the file named file does not exist {6}, see <B>ERRORS AND RETURNS</B>.<p>
If options are specified, the validity of the option-arguments will be checked. If an invalid option is specified {3a}, see <B>ERRORS AND RETURNS</B>. The arguments must be processed in the order specified (e.g., if the modify option is specified with a user, followed by the delete option with ihe same user, the entry will be deleted).<p>
For the <B>-m</B>, <B>-s</B>, and <B>-d</B> options, if uid is not a valid login name or a valid user ID {3b}, or if gid is not a valid group name or a valid group ID {3c}, or if a specified perm is not r, w, x, -, or a specified operm is not an octal digit {3d}, see <B>ERRORS AND RETURNS</B>.<p>
The <B>-m</B> option is used to add a new ACL entry or change an existing ACL entry.<p>
If an entry already exists for the specified uid or gid. the specified permissions (perm operm) will replace the current permissions. If an entry does not exist for the specified uid or gid, an entry will be created. Note that an entry with no permissions will result in the specified uid or gid being denied access (any permissions) to the file. To specify no access in an entry being modified or added, either 0 should be specified for operm or - should be specified for perm.<p>
The <B>-s</B> option is used to replace the ACL information on a file. The effect of using this option is that all entries are removed, and replaced by the newly specified ACL. If -s is specified with -d, -f, or -m {5}, see <B>ERRORS AND RETURNS</B>. There must be exactly one <B>user</B> entry specified for the file owner, exactly one <B>group</B> entry specified for the file owning group, exactly one <B>class</B> entry specified for the file group class, and exactly one <B>other</B> entry specified. If there is no user entry specified for the file owner. or no group entry specified for the file owning group or no class entry specified for the file group class, or no other entry specified {8}, see <B>ERRORS AND RETURNS</B>. There may be additional user ACL entries and additional group ACL entries specified. If duplicate entries are specified {9}, see <B>ERRORS AND RETURNS</B>.<p>
The <B>-d</B> option is used to delete an existing entry from the ACL. If a matching entry is not found {4a}, see <B>ERRORS AND RETURNS</B>. Otherwise, the matching entry will be deleted. The <B>user</B> entry for the file owner, the <B>group</B> entry for the file owning group, the <B>class</B> entry, and the <B>other</B> entry may not be deleted from the ACL. If an attempt is made to delete one of these entries {4b}, see <B>ERRORS AND RETURNS</B>.<p>
(Note: deleting an entry may have different effects than removing all the specified permissions for an entry. If an entry is deleted and a search is later done for the user or group identity that appeared in the entry, this identity might match another entry and then be given the permissions specified in this other entry. If the original entry remained with no permissions and a search was done for this identity. the search might match this entry and the subject would be denied access.)<p>
The <B>-f</B> option is used to assign the ACL information contained in the file named <EM>acl_file</EM> to the specified file(s). If -f is specified with -d. -s. or -m {5}, see <B>ERRORS AND RETURNS</B>. If the file named <EM>acl_file</EM> does not exist {6}, see <B>ERRORS AND RETURNS</B>. The file named <EM>acl_file</EM> must be readable by the invoking subject. If it is not readable {2}, see <B>ERRORS AND RETURNS</B>.<p>
If the entire file named <EM>acl_file</EM> contains correct external representation(s) for ACL entries, the ACL for the specified file(s) will be (removed and) replaced with the ACL whose external representation is contained in the file named <EM>acl_file</EM>. Each external representation of an ACL entry, contained in the file named <EM>acl_file</EM>, must be on a separate line and must be in the following format:<p>
<DL>
<DD>u[ser]::operm perm
<DD>[u[ser]:uid:operm perm]
<DD>g[roup]::operm perm
<DD>[g[roup]:gid:operm perm]
<DD>c[lass]:operm perm
<DD>o[ther]:operm perm
<DD>[d[efault]:u[ser]::operm perm]
<DD>[d[efault]:u[ser]:uid:operm perm[,...]]
<DD>[d[efault]:g[roup]::operm perm]
<DD>[d[efault]:g[roup]:gid:operm perm[,...]]
<DD>[d[efarnlt]:c[lass]:operm perm]
<DD>[d[efault]:o[ther]:operm perm]
</DL>
The entries are not required to be in any specific order within the file.<p>
There must be exactly one <B>user</B> entry specified for the file owner, exactly one <B>group</B> entry specified for the file owning group, exactly one <B>class</B> entry specified for the file group class, and exactly one <B>other</B> entry specified. If not, see <B>ERRORS AND RETURNS</B>. There may be additional user ACL entries and additional group ACL entries specified. If duplicate entries are specified {9}, see <B>ERRORS AND RETURNS</B>.<p>
Validity checks are performed on all entries. If an invalid entry is encountered {7}; see <B>ERRORS AND RETURNS</B>. If the exact problem can be determined an additional message may be displayed {3b}{3c}{3d}, see <B>ERRORS AND RETURNS.</B><p>
The character "#" will be used to indicate a comment. All characters
 starting with the #. to the end of the line will be ignored. Note that
 this includes any effective permissions (#effective:rwx) displayed by
 <B>getacl</B>.<p>
 This command may be executed on a file system that does not support
 ACLs. If ACL entries are specified which do not map into the base
 permissions {10}, see <B>ERRORS AND RETURNS</B>, otherwise the base permissions
 will be set.<p>
ERRORS AND RETURNS: Following is a list of error conditions and the
 corresponding error message that should be output when this condition
 occurs.
 <p>
<DL>
usage: setacl [-r] [ -m [rn(ser]::operm perm[.]]
<DD>[rn[ser]:uid:operm perm[,...J]
<DD>[g[roup]::operm perm[,]]
<DD>[g[roup]:gid:operm perm[....]]
<DD>[c[lass]:operm perm[,]]
<DD>[o[ther]:operm perm[,]]
<DD>[d(efault]:u[ser]::operm perm]
<DD>(d(efarnlt]:u[ser]:uid:operm perm(9...]]
<DD>[d[efault]:g[roup]::operm perm]
<DD>[d[efault]:g[roup]:gid:operm perm[,...]]
<DD>[d[efault]:c[lass]:operm perm]
<DD>[d[efault]:o[ther]:operm perm]
<DD>]
<DD>-d [u[ser]:uid[,...]][g[roup]:gid(,...]] [d
<DD>[efault]:u(ser]:]
<DD>fd [efault]:u[ser]:uid[,...]] [d[efault]:g[roupj:[,...]]
<DD>[d[efault]:g(roup]:gid] [d[efarnlt]:o[ther]:]]
<DD>file...
</DL>
or<p>
<DL>
setacl [-r] -s rn(ser]::operm perm[,]
<DD>[rn[ser']:uid:operm perm[,...]]
<DD>g[roup]::operm perm(.]
<DD>[g[roup]:gid:operm perm[,...]]
<DD>c[lass]:operm perm[,]
<DD>o[ther]:operm perm[,]
<DD>[d[efault]:u[ser]::operm perm]
<DD>[d[efault]:u[ser]:uid:operm perm[9...]]
<DD>[d[efault]:g[roup]::operm perm]
<DD>[d[efault]:g[roup]:gid:operm perm[....]]
<DD>[d[efault]:c[lass]:operm perm]
<DD>[d[efault]:o[ther]:operm \\perm]
<DD>file
</DL>
or<p>
 setacl [-r] -f acljile file<p>
{1} No options or arguments:<p>
<DL>
<DD>UX:setacl: ERROR: incorrect usage
<DD>usage: ...
</DL>
{2} If MAC or DAC check fails on the specified file:<p>
<DL>
<DD> UX:setacl: ERROR: permission denied for "<EM>filename</EM>"
</DL>
{3} invalid option-arguments:
<DL>
<DD>{a} incorrect/unknown option specified:
<DL>
<DD>UX:setacl: ERROR: illegal option -- "-option"
<DD>usage: ...
</DL>
<DD>{b} invalid user ID:
<DL>
<DD>UX:setacl: ERROR: unknown user-id "uid"
</DL>
<DD>{c} invalid group ID:
<DL>
<DD>UX:setacl: ERROR: unknown group-id "gid"
</DL>
<DD>{d} invalid permission:
<DL>
<DD>UX:setacl: ERROR: unknown permission "permission"
<DD>usage: ...
</DL>
</DL>
{4}invalid attempt to delete an ACL entry:<p>
<DL>
<DD>{a} attempt to delete a non-existent entry from an ACL:
<DL>
<DD>UX:setacl: ERROR: matching entry not found in ACL
</DL>
<DD>{b} attempt to delete file owner, file owning group. class. or 
 other ACL entries:
<DL>
<DD>UX:setacl: ERROR: file owner, file group, "class". and "other"
 entries may not be deleted
</DL>
</DL>
{5} the options specified are mutually exclusive:
<DL>
<DD>UX:setacl: ERROR: incompatible options specified usage:
</DL>
{6} filename does not exist:
<DL>
<DD>UX:setacl: ERROR: file `file,name" not found
</DL>
{7} an invalid ACL entry encountered in the file acl_file:
<DL>
<DD>UX:setacl: ERROR: "acl_file", line line; invalid ACL entry
</DL>
{8} required entry for file owner, file owning group, class, or other missing:
<DL>
<DD>UX:setacl: ERROR: required entry for file owner, file group, "class", or "other" not specified
<DD>usage: ...
</DL>
{9} duplicate ACL entries specified:
<DL>
<DD>UX:setacl: ERROR: duplicate entries: "acl,entry"
</DL>
{10} the file system does not have ACLs, and additional entries are specified:
<DL>
<DD>UX:setacl: ERROR: only file owner, file group, "class" or "other" entries may be specified
</DL>
{11} the specified file is not a directory, and default entries have been specified:
<DL>
<DD>UX:setacl: ERROR: default ACL entries may only be set on directories
</DL>
OUTPUT: None<p>
<H2>A.2.2 getacl Command</H2>
DESCRIPTION: The getacl command will support (he displaying of discretionary<p>
 information associated with a file. It will allow the file owner or a<p>
 process with appropriate permission or appropriate privilege to<p>
 perform the following functions:<p>
 1. display the owner, group, and ACL for the specified file(s),<p>
 2. display the default ACL for a directory.<p>
 Note that this command only supports the file system objects: e.g.,<p>
 regular files, special files, directories. and named pipes. For<p>
 simplicity, these objects are referred to as "files".<p>
SYNOPSIS:<p>
 getacl [-ad] file<p>
PROCESSING: With no arguments (1), see <B>ERRORS AND RETURNS. If MAC or</B><p>
 DAC check fails when a request is made to display the ACL information<p>
 (2) see <B>ERRORS AND RETURNS</B>. With invalid options (3), see ERRORS AND<p>
 RETURNS. If the file named file does not exist (4), see ERRORS AND<p>
 RETURNS.<p>
 With the <B>-a option specified, the filename, owner, group, and the ACL of</B><p>
 the file will be displayed. With the <B>-d option specified, the filename,</B><p>
 owner, group, and the default ACL of the file will be displayed, if it<p>
 exists. If the specified file does not support default ACLs (e.g., it is not a<p>
 directory) only the filename, owner, and group will be displayed. With<p>
 no option specified, both the ACL and the default ACL (if it exists) of the <p>
 file will be displayed.<p>
 This command may be executed on a file system that does not support<p>
 ACLs. It will report the ACL based on the base permission bits.<p>
<B>ERRORS AND RETURNS: Following is a list of error conditions and the</B><p>
 corresponding error message that should be output when this condition<p>
 occurs.<p>
 <p>
 usage: getacl [-ad] file<p>
 (1) No arguments:<p>
 UX:getacl: ERROR: incorrect usage<p>
 usage:...<p>
 (2) If MAC or DAC check fails when a request is made to display the ACL<p>
 information:<p>
 UX:getacl: ERROR: permission denied for "file"<p>
 <p>
 (3) incorrect/unknown option specified:<p>
 UX:getacl: ERROR: illegal option -- "-optio,t"<p>
 usage:...<p>
 <p>
 (4) file does not exist:<p>
 UX:setacl: ERROR: file "file" not found<p>
OUTPUT: When an ACL is displayed, the external representation of the ACL will<p>
 be as follows:<p>
 # file: filename<p>
 # owner: uid<p>
 # group: gid<p>
 user::perm<p>
 inser:uid:perm<p>
 group::perm<p>
 group:gid:perm<p>
 class:perm<p>
 other:perm<p>
 default :user: :perm<p>
 default :user:uid:perm<p>
 defai,lt :group: :perm<p>
 default :group :gid :perm<p>
 default :class :perm<p>
 default :other :perm<p>
 The ACL entries will be displayed in the order listed above (the user<p>
 entry for the file owner, followed by zero or more additional user<p>
 entries, followed by the group entry [or the file owning group, followed<p>
 by zero or more additional group entries, followed by the class entry<p>
 for the file group class, followed by the entry for other). When the<p>
 specified file is a directory the entries described above may be<p>
 followed by default entries (the default user entry for the file<p>
 owner, followed by zero or more additional default:user entries,<p>
 followed by the default:group entry for the file owning group,<p>
 followed by zero or more additional default:group entries, followed<p>
 by the default:class entry for the file group class, followed by the<p>
 entry for default:other). Note that these default ACL entries are<p>
 never used in an access check.<p>
 If more than one file is specified, a blank line will be displayed<p>
 before the ACL of the next file is displayed.<p>
The first line displays the name of the file, next the file owner, and then the file owning group. The user entry without a user ID indicates the permissions that will be granted to the owner of the file. The additional user entries indicate the permissions that will be granted to the specified user. The group entry without a group indicates the permissions that will be granted to the group of the file. The additional group entries indicate the permissions that will be granted to the specified group. The class entry indicates the permissions that will be granted to the file group class. The other entry indicates the permissions that will be granted to others.<p>
The default entries (default:user, default:group, default:class, and default:other) may only exist for directories, and indicate the default user, group, class, and other entries respectively that will be merged with the ACL for a new file created within the directory.<p>
The uid is a login name, or a user ID (only if there is no login name associated with the user ID); gid is a group name. or a group ID (only if there is no group name associated with the group ID); and perm is a three character string composed of the letters representing the separate discretionary access controls, r (read). w (write), x (execute/search), or the character -. The perm will be displayed in the following order: rwx. If a permission is not granted by this ACL entry. the placeholder. "-", will appear. For example. if the user does not have write permission. but does have read and execute permission, r-x will be output.<p>
The file group class permission bits constrain the ACL (represent the most access that any entry in the ACL may have). If a user executes the chmod command and changes the file group class permission bits this may change the permissions that would be granted based on the ACL alone. This behavior is necessary for the save-restore model (all permissions are temporarily removed via <B>chmod 000 file and then restored) to work correctly. In order to indicate that the file permission bits are more restrictive than an ACL entry, getacl will display the ACL entry as described above with an additional tab followed by a sharp sign and the effective permissions.</B><p>
Note that output from getacl will be in the correct format for input to setacl. Therefore, if the output is redirected into a file (e.g., getacl junk &gt; entries), this file can be used as input to setacl (e.g., setacl -f entries junk.new). In this way, a user can easily assign one file's ACL information to another file.<p>
EXAMPLES:<p>
1) File with several ACL entries:<p>
#file:fred<p>
#owner:craig<p>
# group: demo<p>
user::rwx<p>
user:spy:---<p>
user:larry:rw-<p>
group::r--<p>
class:rw-<p>
other:---<p>
2) Same file. after a "chmod 700 fred":<p>
#file:fred<p>
$ owner: craig<p>
$ group: demo<p>
user::rwx<p>
user:spy:---<p>
user:larry:rw- #effective:---<p>
group::r-- $effective:---<p>
class:---<p>
other:---<p>
3) Directory with ACL entries including default ACL entries:<p>
$ file: foodir<p>
$ owner: craig<p>
$ group: demo<p>
user::rwx<p>
user:spy:---<p>
user:larry:rwx<p>
group::r-x<p>
class:rwx<p>
other:r--<p>
default:user::rwx<p>
default user :larry :rwx<p>
default:rnser:worm:- --<p>
default :group:demo:r -<p>
default:other:---<p>
<UL><H2>2.3 acl Function</H2></UL>
DESCRIPTION: The act call will support the getting and setting of<p>
 discretionary permission information associated with a file. It will<p>
 allow the file owner or a process with appropriate permission or<p>
 appropriate privilege to perform the following functions:<p>
 1. get or set a file's ACL information in an atomic operation.<p>
 2. return the number of entries contained in an file's ACL.<p>
 Note that this call only supports the file system objects: e.g., regular<p>
 files, special files, directories, and named pipes. For simplicity,<p>
 these objects are referred to as "files".<p>
SYNOPSIS:<p>
 #include &lt;tbd.h&gt;<p>
 int acl(const char *path, int cmd. int nentries, struct acl "aclbufp)<p>
 Three values for cmd will be supported: ACLSET, ACLGET, and ACL_CNT.<p>
 The value of nentries is the number of ACL entries that can fit in the<p>
 user-supplied ACL buffer for an ACL_GET or the number actually present<p>
 for an ACL_SET; and aclbufp is a pointer to the user-supplied buffer of<p>
 ACL entry structures. The buffer will consist of an array of four<p>
 (USER_OBJ, GROUP_OBJ, CLASS_OBJ, and OTHER_OBJ entries are required) or<p>
 more occurrences of the following structure:<p>
 struct acl [<p>
 int a_type;<p>
 uid_t a_id;<p>
 ushort a_perm;<p>
 ];<p>
 Twelve values of a_type will be supported to specify the type of entry:<p>
 (six for access checking and six for defaults), USER_OBJ, USER,<p>
 GROUP_OBJ, GROUP, CLASS_OBJ, OTHER_OBJ, DEF_USER_OBJ, DEF_USER,<p>
 DEF_GROUP_OBJ, DEF_GROUP, DEF_CLASS_OBJ, and DEF_OTHER_OBJ.<p>
 When a_type is USER or DEF_USER, aid will be a user id, and when a_type<p>
 is GROUP or DEF_GROUP, aid will be a group id. When a_type is USER_OBJ,<p>
 GROUP_OBJ, CLASS_OBJ, OTHER_OBJ, DEF_USER_OBJ,<p>
 DEF_GROUP_OBJ, DEF_CLASS_OBJ, or DEF_OTHER_OBJ, a_id will not be<p>
 used. The permissions for the entry will be contained in a_perm.<p>
PROCESSING: When the specified cmd is <B>ACL_CNT, the return value from the call</B><p>
 will be the number of ACL entries for the filename pointed to by path.<p>
 The values of nentries and aclbitfp will be ignored. If the user does<p>
 not pass the DAC and MAC checks to see the ACL. the acl call will fail<p>
 (see <B>ERRORS AND RETURNS).</B><p>
 When the specified cmd is <B>ACL_GET. the ACL information for the filename</B><p>
 pointed to by path will be retrieved and the ACL entries will be<p>
 placed in the buffer pointed to by aclbufp. The value of nentries is<p>
 the number of entries that can be held in the allocated buffer. If<p>
 the number of ACL entries in the ACL is greater than the value of<p>
 nentries (that is. the buffer space allocated to hold the files ACL<p>
 entries is less than nentries times the size of an entry), the acl<p>
 call will fail (see <B>ERRORS AND RETURNS). On success. the return value</B><p>
 from this call will be the number of ACL entries retrieved. On any<p>
 error, the contents of the acl structures pointed to by aclbufp are<p>
 indeterminate. If the user does not pass the DAC and MAC checks to see<p>
 the ACL, the acl call will fail (see <B>ERRORS AND RETURNS).</B><p>
 When the specified cmd is <B>ACL_SET, ACL entries currently in the buffer</B><p>
 pointed to by aclbufp, for the filename pointed to by path, will be<p>
 set if all required checks are passed. The contents of nentries shall be<p>
 the number of ACL entries in the buffer, pointed to by aclbufp, to be<p>
 copied. On success, the return value from this call will be 0. If the<p>
 invoking user does not pass the DAC and MAC checks to set an ACL, the<p>
 act call will fail (see <B>ERRORS AND RETURNS). If an error occurs,</B><p>
 either due to DAC and MAC checks or the validation check listed below,<p>
 there will be no change to the current ACL information. Before the ACL<p>
 entries are actually set, validation checks will be performed to<p>
 determine that the ACL entries are in the following order:<p>
 a) a user entry for the file owner (<B>USER_OBJ),</B><p>
 <p>
 b) additional user entries (<B>USER),</B><p>
 <p>
 c) a group entry for the file owning group (<B>GROUP_OBJ),</B><p>
 <p>
 d) additional group entries (<B>GROUP),</B><p>
 <p>
 e) a class entry for the file group class (<B>CLASS_OBJ),</B><p>
 <p>
 f) an entry for other (<B>OTHER_OBJ),</B><p>
 <p>
 g) default user entry for the file owner (<B>DEF_USER_OBJ),</B><p>
 <p>
 h) default additional user entries (<B>DEF_USER),</B><p>
 i) default group entry for the file owning group (<B>DEF_GROUP_OBJ),</B><p>
 j) default additional group entries (<B>DEF_GROUP),</B><p>
 k) default class entry for file group class (<B>DEF_CLASS_OBJ).</B><p>
 l) default entry for other (<B>DEF_OTHER_OBJ),</B><p>
The entry in classes a), c), e), and f) must always exist. The entry for classes a), c), e), f), g), i), k), and l) do not use the a_id field. Classes b) and h) may contain zero or more entries and the entries must be sorted by uid (lowest to highest). Classes d) and j) may contain zero or more entries and the entries must be sorted by gid (lowest to highest). (this ordering should be done with the aclsort function).<p>
Class g), h), i), j), k), and l) entries are only applicable for directories. If an attempt is made to set default ACL entries on a file that is not a directory, the call will fail (see <B>ERRORS AND RETURNS).</B><p>
Validation of the ACL will be performed. If entries containing duplicate uids or gids are found, or there is not exactly one <B>user entry specified for the file owner, one group entry specified for the file owning group, one class entry specified for the file group class, and one other entry specified, or there are no additional user and group entries and the permissions of the class entry are not equal to the permissions of the group entry, or there are no additional default:user and default:group entries and the permissions of the default:class entry is not equal to the permissions of the default:group entry, the call will fail (see <B>ERRORS AND RETURNS</B>).</B><p>
The file owner class permission bits will be changed, such that they are equal to the permissions specified for the <B>user entry of the file owner in the ACL. The file group class permission bits will be changed, such that they are equal to the permissions specified for the class ACL entry. The file other class permission bits will be changed, such that they are equal to the permissions specified for the other ACL entry.</B><p>
This function may be executed on a file system that does not support ACLs. With ACL_GET as the cmd it will report the ACL based on the file permission bits. With ACL_SET as the cmd, if ACL entries are specified which do not map into the file permission bits, see <B>ERRORS AND RETURNS, otherwise the file permission bits will be set.</B><p>
A design may constrain the maximum number of ACL entries that are written, with a system-wide tunable parameter, <B>aclmax. If the number ofACL entries exceeds the value of aclmax the function will fail (see <B>ERRORS AND RETURNS</B>).</B><p>
ERRORS AND RETURNS: If the acl call is unsuccessful, a value of <B>-l will be</B><p>
 returned and errno will be set to indicate the error. Only<p>
 implementation-independent errnos are presented.<p>
 Under the following conditions, the function act will fail and will<p>
 set errno to the specified value (note: unless otherwise stated, the<p>
 errno applies to ACL_CNT, ACL_GET, and ACL_SET):<p>
 ENOTDIR if a component of the path prefix is not a directory<p>
 ENOTDIR if an attempt is made to set a default ACL on a file<p>
 type other than a directory<p>
 ENOENT if a component of the pathname should exist but does not<p>
 EACCES if the DAC and/or MAC check fails<p>
 EINVAL if cmd is not ACL_CNT, ACL_GET, or ACL_SET<p>
 EINVAL if cmd is ACL_SET and the ACL entries do not pass the<p>
 validation check<p>
 ENOSPC if cmd is ACLGET and the space required for the<p>
 file's ACL entries exceeds nentries<p>
 ENOSPC if cmd is ACL,SET and there is insufficient space<p>
 in the file system to store the ACL<p>
 EINVAL if the number of acl entries exceeds the value of <B>aclmax</B><p>
 ENOSYS if the file system type does not support ACLs, and<p>
 additional entries are specified<p>
<UL><H2>2.4 aclsort Function</H2></UL>
DESCRIPTION: The aclsort function will take as input a buffer containing ACL<p>
 entries (including default ACL entries) and sort them into the correct<p>
 order to be accepted by the act or the aclipc function. It will<p>
 optionally calculate the maximum permissions needed for the object group<p>
 class and set the <B>class ACL entry.</B><p>
SYNOPSIS:<p>
 $include &lt;tbd.h&gt;<p>
 int aclsort(int nentries, int calclass, struct acl *aclbufp)<p>
 Where the value of nentries is the number of ACL entries, the value of<p>
 calclass if non-zero indicates to recalculate the <B>class entry, and</B><p>
 aclbufp is a pointer to ACL entry structures.<p>
PROCESSING: A call to aclsort will result in the contents of the buffer<p>
 being sorted in the following order:<p>
 a) a user entry for the object owner,<p>
 b) additional user entries.<p>
 c) a group entry for the object owning group,<p>
 d) additional group entries,<p>
 e) a class entry for the file group class,<p>
 f) an entry for other,<p>
 g) default user entry for the object owner.<p>
 h) default additional user entries,<p>
 i) default group entry for the object owning group.<p>
 j) default additional group entries,<p>
 k) default class entry for the file group class,<p>
 l) default entry for other.<p>
 Classes a), c), e), and f) must each have exactly one entry, if not,<p>
 see <B>ERRORS AND RETURNS. Classes g), i), k), and l) must have zero or</B><p>
 one entry, if not, see <B>ERRORS AND RETURNS. Entries will be sorted in</B><p>
 increasing order, by user ID in classes b) and h), and by group ID in<p>
 classes d) and j). Following sorting, a check will be performed to verify that no<p>
 duplicate entries (more than one entry containing the same user ID or the same<p>
 group ID) exist. If duplicate entries are found, see <B>ERRORS AND RETURNS.</B><p>
 If there are no entries in classes b) and d). the function will set<p>
 the permission field, a_perm. in the class entry e) to that of the group<p>
 entry c). If there are entries in classes b) or d) and the calclass<p>
 argument is non-zero, the function will set the permission field,<p>
 a_perm, of the <B>class entry to the maximum permission of the entries in</B><p>
 the file group class. Otherwise, the <B>class entry permissions will remain</B><p>
 unchanged.<p>
 If there are no entries in classes h) and j), the function will set<p>
 the permissions in the default class entry k) to that of the default<p>
 entry i).<p>
 Upon success. aclsort will return the value 0.<p>
ERRORS AND RETURNS: If the aclsort function is unsuccessful due to duplicate<p>
 entries, the return value will be the position (entry number) of the <p>
 first duplicate entry. If there is less than one <B>user entry for the</B><p>
 object owner, <B>group entry for the object owning group, class entry for</B><p>
 the file group class, or <B>other entry specified, a value of -l will be</B><p>
 returned. If there is more than one <B>user entry for the object owner,</B><p>
 <B>group entry for the object owning group, class entry for the file</B><p>
 group class, or <B>entry specified, they will be treated as duplicate</B><p>
 entries, and the return value will be the position of the duplicate<p>
 entry.<p>
 If the aclsort function is unsuccessful for any other reason, a value of<p>
 <B>-l will be returned.</B><p>
<UL><H2>2.5 chmod Function</H2></UL>
DESCRIPTION: The chmod function supports the following functionality:<p>
 1. it allows a subject to change the file mode. including the<p>
 permissions for the file owner class. the file group class, and the<p>
 file other class of a file.<p>
 Note that the chmod command will not require any modifications.<p>
SYNOPSIS: No change.<p>
PROCESSING: Any permissions changes made with the chmod command or function<p>
 will update the file permission bits. This includes changing the file<p>
 owner ACL entry, the <B>class ACL entry, and the other ACL entry if</B><p>
 the corresponding group(s) of bits are changed by this call. Any<p>
 additional ACL entries will not be affected. Note. the permissions<p>
 granted by such additional entries are constrained by the file group<p>
 class permission bits. If no additional <B>user and no additional group</B><p>
 entries exist, the file <B>group class permission bits will also</B><p>
 represent the permissions for the owning group of the file.<p>
ERRORS AND RETURNS: No change.<p>
OUTPUT: No change.<p>
<UL><H2>2.6 chown Function</H2></UL>
DESCRIPTION: The chown function supports the following functionality:<p>
 1. it allows a subject to change the owner and/or group of a file.<p>
 Note that the chown system call/command and the chgrp command will not<p>
 require any modifications.<p>
SYNOPSIS: No change.<p>
PROCESSING: When the owner of a file is changed, the result will be identical<p>
 to the current behavior. If the owner is changed to a user ID. for<p>
 which an additional <B>user entry already exists in the ACL, the additional</B><p>
 <B>user entry is not changed but the user entry for the file owner will</B><p>
 take precedence during an access check. When the group of a file is<p>
 changed. the result will be identical to the current behavior. If the<p>
 group is changed to a group ID, for which an additional <B>group entry</B><p>
 already exists in the ACL, the additional <B>group entry is not changed but</B><p>
 the <B>group entry for the file owning group will take precedence during an</B><p>
 access check (except in the case of multiple concurrent groups, where<p>
 all group entries are given equal treatment).<p>
ERRORS AND RETURNS: No change.<p>
OUTPUT: No change.<p>
EXAMPLES: The following examples illustrate the operation of the chown<p>
 function. For each example, there is a "before" state showing the<p>
 output of getacl, the chown function that is executed, and the "after"<p>
 state output.<p>
EXAMPLE 1:<p>
BEFORE:<p>
$ file: filel<p>
$ owner: larry<p>
$ group: guest<p>
user::rwx<p>
group::r--<p>
class:r- -<p>
other:---<p>
CALL: chown(filel, lisa, demo)<p>
AFTER:<p>
$file:filel<p>
$ owner: lisa<p>
$ group: demo<p>
user::rwx<p>
group::r--<p>
class:r--<p>
other:---<p>
EXAMPLE 2:<p>
BEFORE:<p>
$ file: file2<p>
$ owner: tarry<p>
$ group: guest<p>
user::rwx<p>
user:fred:r--<p>
group::r--<p>
group:dev:r--<p>
class:r--<p>
other:---<p>
CALL: chown(file2. lisa demo)<p>
AFTER:<p>
$ file: file2<p>
$ owner: lisa<p>
$ group: demo<p>
user::rwx<p>
user:fred:r---<p>
group::r--<p>
group:dev:r--<p>
class:r--<p>
other:---<p>
EXAMPLE 3:<p>
BEFORE:<p>
$ file: file3<p>
$ owner: larry<p>
$ group: guest<p>
user::rwx<p>
user:lisa:r--<p>
user:fred:r--<p>
group::r--<p>
group:dev:r--<p>
group:demo:r--<p>
class:r--<p>
other:---<p>
CALL: chown(file3. lisa, demo)<p>
AFTER:<p>
$ file: file3<p>
$ owner: lisa<p>
$ group: demo<p>
user::rwx<p>
user:lisa:r--<p>
user:fred:r--<p>
group::r--<p>
group:dev:r--<p>
group:demo:r--<p>
class:r--<p>
other:---<p>
Note in EXAMPLE 3, a <B>user entry contains a user ID that is the same as the file owner. In this case the file owner entry takes precedence. Also in EXAMPLE 3, a group entry contains a group ID that is the same as the owning group of the file. If multiple concurrent groups are not being used, the object owning group entry takes precedence.</B><p>
<UL><H2>2.7 aclipc Function</H2></UL>
DESCRIPTION: The aclipc call will support the getting and setting of<p>
 discretionary permission information associated with an IPC object. It<p>
 will allow the object owner or a process with appropriate permission<p>
 or appropriate privilege to perform the following functions:<p>
 1. get or set an IPC object's ACL information in an atomic operation.<p>
 2. return the number of entries contained in an IPC object's ACL.<p>
 Note that this call only supports the IPC objects: e.g., shared memory<p>
 segments. semaphores. and message queues. For simplicity, these<p>
 objects are referred to as "IPC objects" in the remainder of this<p>
 description.<p>
SYNOPSIS:<p>
 #include &lt;tbd.h&gt;<p>
 int aclipc(int type, int id, int cmd, int nentries, struct acl<p>
 *aclbufp)<p>
 Three values for type will be supported: <B>IPC_SHM, IPC_SEM, and IPC_MSG.</B><p>
 If type is <B>IPC_SHM, id must be a valid shmid returned by shmget. If type</B><p>
 is <B>IPC_SEM, id must be a valid semid returned by semget. If type is</B><p>
 <B>IPC_MSG, id must be a valid msgid returned by msgget. Three values for</B><p>
 cmd will be supported: <B>ACL_SET. ACL_GET, and ACL_CNT. The value of</B><p>
 nentries is the number of ACL entries that can fit in the user<p>
 -supplied ACL buffer for an <B>ACL_GET or the number actually present for</B><p>
 an <B>ACL_SET; and aclbufp is a pointer to the user-supplied buffer of ACL</B><p>
 entry structures. The buffer will consist of an array of four<p>
 (<B>USER_OBJ, GROUP_OBJ, CLASS_OBJ, and OTHER_OBJ entries are required)</B><p>
 or more occurrences of the following structure:<p>
 struct acl {<p>
 int a_type;<p>
 uid_t a_id;<p>
 ushort a_perm;<p>
 };<p>
 Six values of a_type will be supported to specify the type of entry:<p>
 <B>USER_OBJ, USER, GROUP_OBJ, GROUP, CLASS_OBJ, and OTHER_OBJ.</B><p>
 When a_type is <B>USER, a_id will be a user id, and when a_type is GROUP,</B><p>
 a_id will be a group id. When a_type is <B>USER_OBJ, GROUP_OBJ, CLASS_OBJ,</B><p>
 or <B>OTHER_OBJ, a_id will not be used. The permissions for the entry will</B><p>
 be contained in a_perm.<p>
PROCESSING: When the specified cmd is <B>ACL_CNT, the return value from the call</B><p>
 will be the number of ACL entries for the IPC object specified by type<p>
 and id. The values of nentries and aclbufp will be ignored. If the<p>
 invoking user does not pass the DAC or MAC checks to see the ACL. the<p>
 aclipc call will fail (see <B>ERRORS AND RETURNS).</B><p>
 When the specified cmd is <B>ACL_GET the ACL information for the IPC object</B><p>
 specified by type and id will be retrieved and the ACL entries will be<p>
 placed in the buffer pointed to by aclbufp. The value of nentries is<p>
 the number of entries that can be held in the buffer. If the number of<p>
 ACL entries in the ACL is greater than the value of nentries (the buffer<p>
 space allocated to hold the file's ACL entries is less than nentries<p>
 times the size of an entry), the aclipc call will fail (see <B>ERRORS AND</B><p>
 <B>RETURNS). On success. the return value from this call will be the number</B><p>
 of ACL entries retrieved. On any error, the contents of the <B>acl</B><p>
 structures pointed to by aclbufp are indeterminate. If the user does<p>
 not pass the DAC and MAC checks to see the ACL, the aclipc call will<p>
 fail (see <B>ERRORS AND RETURNS).</B><p>
 <p>
 When the specified cmd is <B>ACL_SET, ACL entries currently in the buffer,</B><p>
 pointed to by aclbufp, for the IPC object specified by type and id, will<p>
 be set if all required checks are passed. The contents of nentries shall<p>
 be the number of ACL entries in the buffer pointed to by aclbufp to be<p>
 copied. On success, the return value from this call will be 0. If the<p>
 invoking subject does not pass the DAC and MAC checks to set an ACL the<p>
 aclipc call will fail (see <B>ERRORS AND RETURNS). If an error occurs,</B><p>
 either due to DAC or MAC checks or the validation check listed below,<p>
 there will be no change to the current ACL information. Before the ACL<p>
 entries are actually set, validation checks will be performed to<p>
 determine that the ACL entries are in the following order:<p>
 a) a user entry for the IPC object owner (<B>USER_OBJ),</B><p>
 b) additional user entries (<B>USER),</B><p>
 c) a group entry for the IPC object owning group (<B>GROUP_OBJ),</B><p>
 d) additional group entries (<B>GROUP),</B><p>
 e) a class entry for the IPC group class (<B>CLASS_OBJ),</B><p>
 f) an entry for other (<B>OTHER_OBJ).</B><p>
 The entries in class a), c), e), and f) must always exist. The entry<p>
 for class a), c), e), and f) do not use the aid field. Class b) may<p>
 contain zero or more entries and the entries must be sorted by <B>uid (lowest</B><p>
 to highest). Class d) may contain zero or more entries and the entries must be<p>
 sorted by gid (lowest to highest). (this ordering should be done with the aclsort<p>
 function).<p>
 <p>
 Validation of the ACL will be performed. If entries containing duplicate<p>
 uids or gids are found. or there is not exactly; one <B>user entry for</B><p>
 the object owner, one <B>group entry for the object owning group. one class</B><p>
 entry for the IPC group class, or one <B>other entry specified. or there</B><p>
 are no additional user and <B>group entries and the permissions of the</B><p>
 <B>class entry are not equal to the permissions of the group entry, the</B><p>
 call will fail (see <B>ERRORS AND RETURNS).</B><p>
 <p>
 The IPC owner permission bits will be changed, such that they are<p>
 equal to the permissions specified for the <B>user entry of the object</B><p>
 owner in the ACL. The IPC group class permission bits will be<p>
 changed, such that they are equal to the permissions specified for the<p>
 <B>class ACL entry. The IPC other class permission bits will be changed,</B><p>
 such that they are equal to the permissions specified for the <B>other</B><p>
 ACL entry.<p>
 <p>
 A design may constrain the maximum number of ACL entries that are<p>
 written, with a system-wide tunable parameter, <B>aclmax. If the number of</B><p>
 ACL entries exceeds the value of <B>aclmax the function will fail (see</B><p>
 <B>ERRORS AND RETURNS).</B><p>
ERRORS AND RETURNS: If the aclipc call is unsuccessful, a value of <B>-l will be</B><p>
 returned and errno will be set to indicate the error. Only<p>
 implementation-independent errnos are presented.<p>
 Under the following conditions, the function aclipc will fail and will<p>
 set errno to the specified value (note: if cmd is unspecified, the errno<p>
 applies to ACL_CNT, ACL_GET, and ACL_SET):<p>
 EINVAL if type is not IPC_SHM, IPC_SEM, or IPC_MSG<p>
 EINVAL if the value of id is (1) not a valid message_queue_identifier<p>
 and the type was IPC_MSG, (2) not a valid semaphore_identifier<p>
 and the type was IPC_SEM, or (3) not a valid shared memory,<p>
 identifier and the type was IPC_SHM<p>
 EINVAL if cmd is not ACL_CNT, ACL_GET, or ACL_SET<p>
EINVAL if cmd is ACL_SET and the ACL entries do not pass<p>
 the validation check<p>
EACCES if the DAC and/or MAC check fails<p>
ENOSPC if cmd is ACL_GET and the space required for the<p>
 IPC's object ACL entries exceeds nentries<p>
ENOMEM if cmd is ACL_SET and there is insufficient<p>
 space to store the ACL<p>
EINVAL if the number of acl entries exceeds the value of <B>aclmax</B><p>
<UL><H2>2.8 shmctl, semctl, &amp; msgctl Functions</H2></UL>
DESCRIPTION: The shmctl. semctl, and msgctl functions support the following<p>
 functionality:<p>
 1. they allow a subject to change the user ID. group ID, and<p>
 permissions on IPC objects.<p>
SYNOPSIS: No change.<p>
PROCESSING: No change.<p>
ERRORS AND RETURNS: No change.<p>
<H1><A NAME="HDR 2 102"> REFERENCES</A></H1>
[1] Department of Defense Trusted Computer Systems Evaluation Criteria. DoD<p>
5200.28-STD, December 1985.<p>
[2] National Computer Security Center, A Guide to Understanding Discretionary Access Control in Trusted Systems, NCSC-TG-003 Version-I, September 1987.<p>
[3] UNIX System Access Control List Proposal, C. Rubin, AT&amp;T. May 15. 1988.<p>
[4] Adding Access Control Lists To UNIX, A. Silverstein, B. McMahon. G. Nuss,<p>
Hewlett-Packard Co.. March 12. 1988.<p>
[5] Discretionary Access Control System Functions, D. H. Steves, IBM, March 14, 1988.<p>
[6] P1003 .6 Security Extension Proposal: Discretionary Access Control Semantics, W. Olin Sibert. Oxford Systems Inc., May 18. 1988.<p>
[7] PlOO3.6 Supplementary Document: Discretionary Access Control. Problems in P1003.1 Draft 12 , W. Olin Sibert, Oxford Systems Inc.. May 18, 1988.<p>
[8] P1003.6 Supplementary Document: Comments on Hewlett-Packard ACL Proposal, W. Olin Sibert. Oxford Systems Inc., May 18,1988.<p>
[9] Extending The UNIX Protection Model with Access Control Lists, G. Fernandez, L. Allen, Apollo Computer Inc., June 1988.<p>
[10] On Incorporating Access Control Lists into the UNIX Operating System S. M. Kramer, SecureWare Inc., June 1988.<p>
[11] Trusted UNIX Discretionary Access and Privilege Control Mechanisms, B.D.<p>
Wilner, Infosystems Technology Inc.. June 2,1988.<p>
(12] Access Control List Design, Hewlett Packard, October 21, 1988.<p>
[13] Proposal for Adding Access Control Lists to POSIX, P. B. Flinn, SecureWare Inc., July 25, 1988.<p>
[14] Discretionary Access Control Proposal, H. L. Hall, Digital Equipment Corporation, Oct. 1988.<p>
[15] Portable Operating System Interface for Computer Environments IEEE Std. 1003.1-1988<p>
</BODY>
</HTML>
